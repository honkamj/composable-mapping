window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "composable_mapping", "modulename": "composable_mapping", "kind": "module", "doc": "<p>Library for handling spatial coordinate transformations in PyTorch.</p>\n\n<p>Developed originally for medical imaging, this library provides a set of classes\nand functions for handling spatial coordinate transformations.</p>\n\n<p>The most powerful feature of this library is the ability to easily compose\ntransformations lazily and resample them to different coordinate systems as well\nas sampler classes for sampling volumes defined on regular grids such that the\noptimal method (either slicing operation, convolution, or torch.grid_sample) is\nused based on the sampling locations.</p>\n\n<p>The main idea was to develop a library that allows handling of the coordinate\nmappings as if they were mathematical functions, without losing much performance\ncompared to more manual implementation.</p>\n\n<p>In this codebase tensor shapes are seen as consisting of three parts (in the\nfollowing order): batch dimension, channel dimensions and spatial dimensions.\nThe split is defined by providing the number of channel dimensions with the\nassumption that there is at most one batch dimension. If the number of\ndimensions equals the number of channel dimensions, the batch dimension is\nassumed to be empty. Codebase implements custom broadcasting operations which\napply normal broadcasting separately to each split. This makes many operations\neasier as one does not have to worry about unsqueezing correct number of\ndimensions to apply the same operation e.g. over all spatial and batch\ndimensions.</p>\n"}, {"fullname": "composable_mapping.Affine", "modulename": "composable_mapping", "qualname": "Affine", "kind": "class", "doc": "<p>Affine mapping.</p>\n\n<p>This class represents an affine transformation applicable to mappable\ntensors. In essence, it is a wrapper around an affine transformation object\nwhich acts on PyTorch tensors. Since it is a composable mapping, it can be\ncomposed with other mappings.</p>\n\n<p>Recommended way to create an affine transformation is to use the factory\nfunctions provided in this module or as class methods of this class:\n<code>affine</code>, <code>diagonal_affine</code>, <code>Affine.identity</code>,\n<code>Affine.from_matrix</code>, <code>Affine.from_diagonal_and_translation</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>transformation:</strong>  The wrapped affine transformation acting on PyTorch tensors.</li>\n</ul>\n", "bases": "composable_mapping.tensor_like.BaseTensorLikeWrapper, composable_mapping.composable_mapping.composable_mapping.ComposableMapping"}, {"fullname": "composable_mapping.Affine.__init__", "modulename": "composable_mapping", "qualname": "Affine.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">transformation</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IAffineTransformation</span></span>)</span>"}, {"fullname": "composable_mapping.Affine.transformation", "modulename": "composable_mapping", "qualname": "Affine.transformation", "kind": "variable", "doc": "<p>The wrapped affine transformation action on PyTorch tensors.</p>\n", "annotation": ": composable_mapping.affine_transformation.affine_transformation.IAffineTransformation"}, {"fullname": "composable_mapping.Affine.from_matrix", "modulename": "composable_mapping", "qualname": "Affine.from_matrix", "kind": "function", "doc": "<p>Create affine mapping from an affine transformation matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix:</strong>  Affine transformation matrix with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Affine mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_mapping</span><span class=\"o\">.</span><span class=\"n\">Affine</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.Affine.from_diagonal_and_translation", "modulename": "composable_mapping", "qualname": "Affine.from_diagonal_and_translation", "kind": "function", "doc": "<p>Create affine mapping from diagonal and translation</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>diagonal:</strong>  Diagonal of the affine transformation matrix with shape\n([*batch_shape, ]diagonal_length[, *spatial_shape]).</li>\n<li><strong>translation:</strong>  Translation of the affine transformation matrix\nwith shape ([*batch_shape, ]n_output_dims[, *spatial_shape]).</li>\n<li><strong>matrix_shape:</strong>  Shape of the affine transformation matrix in format\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</li>\n<li><strong>dtype:</strong>  Data type of the affine transformation matrix, needed only if diagonal\nand translation are not provided.</li>\n<li><strong>device:</strong>  Device of the affine transformation matrix, needed only if diagonal\nand translation are not provided.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Affine mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">diagonal</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">matrix_shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_mapping</span><span class=\"o\">.</span><span class=\"n\">Affine</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.Affine.identity", "modulename": "composable_mapping", "qualname": "Affine.identity", "kind": "function", "doc": "<p>Create identity affine mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n_dims:</strong>  Number of input and output dimensions of the identity affine mapping.</li>\n<li><strong>dtype:</strong>  Data type of the identity affine mapping.</li>\n<li><strong>device:</strong>  Device of the identity affine mapping.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Identity affine mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">n_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_mapping</span><span class=\"o\">.</span><span class=\"n\">Affine</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.Affine.default_sampling_data_format", "modulename": "composable_mapping", "qualname": "Affine.default_sampling_data_format", "kind": "variable", "doc": "<p>Default data format to use in sampling and resampling operations for\nthe mapping.</p>\n\n<p>If None, DataFormat.world_coordinates() will be used but the behaviour\nin operations with other mappings is different as the default data format\nof the other mapping will be used.</p>\n", "annotation": ": composable_mapping.sampler.interface.DataFormat"}, {"fullname": "composable_mapping.Affine.invert", "modulename": "composable_mapping", "qualname": "Affine.invert", "kind": "function", "doc": "<p>Invert the mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arguments:</strong>  Arguments for the inversion.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The inverted mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">arguments</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">ComposableMapping</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.BaseSeparableSampler", "modulename": "composable_mapping", "qualname": "BaseSeparableSampler", "kind": "class", "doc": "<p>Base sampler in voxel coordinates which can be implemented as a\nseparable convolution</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>extrapolation_mode:</strong>  Extrapolation mode for out-of-bound coordinates.</li>\n<li><strong>mask_extrapolated_regions_for_empty_volume_mask:</strong>  Whether to mask\nextrapolated regions when input volume mask is empty.</li>\n<li><strong>convolution_threshold:</strong>  Maximum allowed difference in coordinates\nfor using convolution-based sampling (the difference might be upper\nbounded when doing the decision).</li>\n<li><strong>mask_threshold:</strong>  Maximum allowed weight for masked regions in a\nsampled location to still consider it valid (non-masked).</li>\n<li><strong>limit_direction:</strong>  Direction for evaluating the kernel at\ndiscontinuous points.</li>\n</ul>\n", "bases": "composable_mapping.sampler.interface.ISampler"}, {"fullname": "composable_mapping.BaseSeparableSampler.derivative", "modulename": "composable_mapping", "qualname": "BaseSeparableSampler.derivative", "kind": "function", "doc": "<p>Obtain sampler for sampling derivatives corresponding to the current sampler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_dim:</strong>  Spatial dimension along which to compute the derivative.</li>\n<li><strong>limit_direction:</strong>  Direction in which to compute the derivative.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampler for sampling derivatives.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">limit_direction</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">GenericSeparableDerivativeSampler</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.BaseSeparableSampler.inverse", "modulename": "composable_mapping", "qualname": "BaseSeparableSampler.inverse", "kind": "function", "doc": "<p>Obtain sampler for sampling inverse values corresponding to the\ncurrent sampler, if available.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>coordinate_system:</strong>  Coordinate system of the mapping.</li>\n<li><strong>data_format:</strong>  Data format of the sampled volume.</li>\n<li><strong>arguments:</strong>  Additional arguments for the inverse.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampler for sampling inverse values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">coordinate_system</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>,</span><span class=\"param\">\t<span class=\"n\">data_format</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span>,</span><span class=\"param\">\t<span class=\"n\">arguments</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Mapping</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.BicubicInterpolator", "modulename": "composable_mapping", "qualname": "BicubicInterpolator", "kind": "class", "doc": "<p>Bicubic interpolation in voxel coordinates.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>extrapolation_mode:</strong>  Extrapolation mode for out-of-bound coordinates.</li>\n<li><strong>mask_extrapolated_regions_for_empty_volume_mask:</strong>  Whether to mask\nextrapolated regions when input volume mask is empty.</li>\n<li><strong>convolution_threshold:</strong>  Maximum allowed difference in coordinates\nfor using convolution-based sampling (the difference might be upper\nbounded when doing the decision).</li>\n<li><strong>mask_threshold:</strong>  Maximum allowed weight for masked regions in a\nsampled location to still consider it valid (non-masked).</li>\n</ul>\n", "bases": "composable_mapping.sampler.base.BaseSeparableSampler"}, {"fullname": "composable_mapping.BicubicInterpolator.__init__", "modulename": "composable_mapping", "qualname": "BicubicInterpolator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">extrapolation_mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;border&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mask_extrapolated_regions_for_empty_volume_mask</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">convolution_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0001</span>,</span><span class=\"param\">\t<span class=\"n\">mask_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-05</span></span>)</span>"}, {"fullname": "composable_mapping.BicubicInterpolator.sample_values", "modulename": "composable_mapping", "qualname": "BicubicInterpolator.sample_values", "kind": "function", "doc": "<p>Sample values at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>volume:</strong>  Volume to sample over spatial dimensions\nwith shape (*batch_shape, *channels_shape, *spatial_shape)</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampled values with shape (*batch_shape, *channels_shape, *target_shape).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.BicubicInterpolator.sample_mask", "modulename": "composable_mapping", "qualname": "BicubicInterpolator.sample_mask", "kind": "function", "doc": "<p>Sample mask at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mask:</strong>  Mask to sample over spatial dimensions\nwith shape (*batch_shape, *(1,) * n_channel_dims, *spatial_shape).</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ClearMask", "modulename": "composable_mapping", "qualname": "ClearMask", "kind": "class", "doc": "<p>Clear mask of the input</p>\n", "bases": "composable_mapping.tensor_like.BaseTensorLikeWrapper, composable_mapping.composable_mapping.composable_mapping.ComposableMapping"}, {"fullname": "composable_mapping.ClearMask.invert", "modulename": "composable_mapping", "qualname": "ClearMask.invert", "kind": "function", "doc": "<p>Invert the mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arguments:</strong>  Arguments for the inversion.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The inverted mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">arguments</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ClearMask.detach", "modulename": "composable_mapping", "qualname": "ClearMask.detach", "kind": "function", "doc": "<p>Detach the wrapped tensors from computational graph.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mask</span><span class=\"o\">.</span><span class=\"n\">ClearMask</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ComposableMapping", "modulename": "composable_mapping", "qualname": "ComposableMapping", "kind": "class", "doc": "<p>Base class for mappings composable with each other, and acting on mappable\ntensors.</p>\n\n<p>In general a composable mapping is a callable object that takes coordinates\nas input and returns the mapping evaluated at these coordinates. Composable\nmappings are generally assumed to be independent over the batch and spatial\ndimensions of an input.</p>\n\n<p>As the name suggests, a composable mapping can be additionally composed with\nother composable mappings with the <code>__matmul__</code> operator (@). Composing does\nnot apply resampling, an operation which can be executed separately using\n<code>resample_to</code> method (or <code>GridComposableMapping.resample</code> method for\ncomposable mappings with an assigned coordinate system).</p>\n\n<p>Basic arithmetic operations are also supported between two composable\nmappings or between a composable mapping and a number or a tensor, both of\nwhich return a new composable mapping.</p>\n", "bases": "composable_mapping.tensor_like.ITensorLike, abc.ABC"}, {"fullname": "composable_mapping.ComposableMapping.__call__", "modulename": "composable_mapping", "qualname": "ComposableMapping.__call__", "kind": "function", "doc": "<p>Evaluate the mapping at coordinates.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>coordinates:</strong>  Coordinates to evaluate the mapping at with shape\n([*batch_shape ,]n_dims[, *spatial_shape]).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Mapping evaluated at the coordinates.</p>\n</blockquote>\n\n<p>@public</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ComposableMapping.invert", "modulename": "composable_mapping", "qualname": "ComposableMapping.invert", "kind": "function", "doc": "<p>Invert the mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arguments:</strong>  Arguments for the inversion.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The inverted mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">arguments</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">ComposableMapping</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ComposableMapping.sample_to", "modulename": "composable_mapping", "qualname": "ComposableMapping.sample_to", "kind": "function", "doc": "<p>Evaluate the mapping at the coordinates defined by the target.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target:</strong>  Target coordinate system (or a container with a coordinate system)\ndefining a grid to evaluate the mapping at.</li>\n<li><strong>data_format:</strong>  Data format of the output. Default data format depends\non the mapping, but as a general rule is the same as the data\nformat of the mapping being sampled, or the default data format\nof the left mapping in a composition or other operation. When no\nclear default data format is available,\nDataFormat.world_coordinates() is used. Default data format can\nbe set for a mapping using <code>set_default_sampling_data_format</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Mappable tensor containing the values obtained by evaluating the\n  mapping at the coordinates defined by the target.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ICoordinateSystemContainer</span>,</span><span class=\"param\">\t<span class=\"n\">data_format</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ComposableMapping.resample_to", "modulename": "composable_mapping", "qualname": "ComposableMapping.resample_to", "kind": "function", "doc": "<p>Resample the mapping at the coordinates defined by the target.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>target:</strong>  Target coordinate system (or a container with a coordinate system)\ndefining a grid to resample the mapping at.</li>\n<li><strong>data_format:</strong>  Data format used as an internal representation of the\ngenerated resampled mapping. Default data format depends on the\nmapping, but as a general rule is the same as the data format of\nthe mapping being sampled, or the default data format of the\nleft mapping in a composition or other operation. When no clear\ndefault data format is available, DataFormat.world_coordinates()\nis used. Default data format can be set for a mapping using\n<code>set_default_sampling_data_format</code>.</li>\n<li><strong>sampler:</strong>  Sampler used by the generated resampled mapping. Note that\nthis sampler is not used to resample the mapping, but to sample\nthe generated resampled mapping. If None, the default sampler\nis used (see <code>default_sampler</code>).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Resampled mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ICoordinateSystemContainer</span>,</span><span class=\"param\">\t<span class=\"n\">data_format</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">sampler</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">SamplableVolume</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ComposableMapping.assign_coordinates", "modulename": "composable_mapping", "qualname": "ComposableMapping.assign_coordinates", "kind": "function", "doc": "<p>Assign a coordinate system for the mapping.</p>\n\n<p>This only changes the coordinate system of the mapping, the mapping itself\nis not changed. The coordinate system contained by the mapping affects\nbehaviour of some methods such as <code>GridComposableMapping.sample</code> and\n<code>GridComposableMapping.resample</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>coordinates:</strong>  Coordinate system (or a container with a coordinate system)\nto assign for the mapping.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Mapping with the given target coordinate system.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ICoordinateSystemContainer</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">GridComposableMapping</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ComposableMapping.as_affine_transformation", "modulename": "composable_mapping", "qualname": "ComposableMapping.as_affine_transformation", "kind": "function", "doc": "<p>Obtain the mapping as an affine transformation on PyTorch tensors, if possible.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Affine transformation on PyTorch tensors.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>NotAffineTransformationError:</strong>  If the mapping is not an affine transformation on\nPyTorch tensors.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ComposableMapping.as_affine_matrix", "modulename": "composable_mapping", "qualname": "ComposableMapping.as_affine_matrix", "kind": "function", "doc": "<p>Obtain the mapping as an affine matrix, if possible.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Affine matrix with\n  shape ([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ComposableMapping.default_sampling_data_format", "modulename": "composable_mapping", "qualname": "ComposableMapping.default_sampling_data_format", "kind": "variable", "doc": "<p>Default data format to use in sampling and resampling operations for\nthe mapping.</p>\n\n<p>If None, DataFormat.world_coordinates() will be used but the behaviour\nin operations with other mappings is different as the default data format\nof the other mapping will be used.</p>\n", "annotation": ": Union[composable_mapping.sampler.interface.DataFormat, NoneType]"}, {"fullname": "composable_mapping.ComposableMapping.set_default_sampling_data_format", "modulename": "composable_mapping", "qualname": "ComposableMapping.set_default_sampling_data_format", "kind": "function", "doc": "<p>Set the default data format to use in sampling and resampling operations for\nthe mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data_format:</strong>  Default data format to use in sampling and resampling operations.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Mapping with the default data format set.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">ComposableMapping</span>,</span><span class=\"param\">\t<span class=\"n\">data_format</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">ComposableMapping</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ComposableMapping.__matmul__", "modulename": "composable_mapping", "qualname": "ComposableMapping.__matmul__", "kind": "function", "doc": "<p>Compose with another mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>right_mapping:</strong>  Mapping to compose with.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Composed mapping.</p>\n</blockquote>\n\n<p>@public</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">ComposableMapping</span>,</span><span class=\"param\">\t<span class=\"n\">right_mapping</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">ComposableMapping</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">ComposableMapping</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem", "modulename": "composable_mapping", "qualname": "CoordinateSystem", "kind": "class", "doc": "<p>Represents coordinate system between voxel and world coordinates on a regular grid</p>\n\n<p>Recommended way to create a coordinate system is to use the factory\nmethods provided as class method of this class:\n<code>CoordinateSystem.centered_normalized</code>,\n<code>CoordinateSystem.centered</code>, <code>CoordinateSystem.voxel</code>,\n<code>CoordinateSystem.torch_grid_sample</code>,\n<code>CoordinateSystem.from_affine_matrix</code>,\n<code>CoordinateSystem.from_diagonal_affine_matrix</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_shape:</strong>  Spatial shape of the grid</li>\n<li><strong>to_voxel_coordinates:</strong>  Affine transformation from world to voxel\ncoordinates. This should be the inverse of from_voxel_coordinates\nand can be omitted if from_voxel_coordinates is given. This should\nbe a IHostAffineTransformation meaning that the transformation is\nstored on the host (cpu) until needed on a target device. That is,\nsince the transformation may be used in control flow decisions, and\nwe want to avoid synchronizing the target device with the host.</li>\n<li><strong>from_voxel_coordinates:</strong>  Affine transformation from voxel to world\ncoordinates. This should be the inverse of to_voxel_coordinates\nand can be omitted if to_voxel_coordinates is given. This should\nbe a IHostAffineTransformation meaning that the transformation is\nstored on the host (cpu) until needed on a target device. That is,\nsince the transformation may be used in control flow decisions, and\nwe want to avoid synchronizing the target device with the host.</li>\n</ul>\n", "bases": "torch.nn.modules.module.Module, composable_mapping.composable_mapping.interface.ICoordinateSystemContainer, composable_mapping.tensor_like.BaseTensorLikeWrapper"}, {"fullname": "composable_mapping.CoordinateSystem.__init__", "modulename": "composable_mapping", "qualname": "CoordinateSystem.__init__", "kind": "function", "doc": "<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spatial_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">to_voxel_coordinates</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IHostAffineTransformation</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">from_voxel_coordinates</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IHostAffineTransformation</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "composable_mapping.CoordinateSystem.centered_normalized", "modulename": "composable_mapping", "qualname": "CoordinateSystem.centered_normalized", "kind": "function", "doc": "<p>Create a centered normalized coordinate system.</p>\n\n<p>The coordinate system is normalized such that the grid just fits into the\ncube from -1 to 1 in each dimension. The grid is centered in the cube.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_shape:</strong>  Spatial shape of the grid.</li>\n<li><strong>voxel_size:</strong>  Relative voxel size of the grid.</li>\n<li><strong>fov_convention:</strong>  Convention for defining the field of view, either \"full_voxels\"\nor \"voxel_centers\". If voxels are seens as cubes with the value at the\ncenter, the convention \"full voxels\" includes the full cubes in the field\nof view, while the convention \"voxel_centers\" includes only the centers.\nThe latter results in a field of view that is one voxel smaller in each\ndimension. Similar to the align_corners option in\ntorch.nn.functional.grid_sample.</li>\n<li><strong>dtype:</strong>  Data type of the created coordinate system.</li>\n<li><strong>device:</strong>  Device of the created coordinate system.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Centered normalized coordinate system.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">voxel_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">fov_convention</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;full_voxels&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.centered", "modulename": "composable_mapping", "qualname": "CoordinateSystem.centered", "kind": "function", "doc": "<p>Create centered coordinate system with a given voxel size.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_shape:</strong>  Spatial shape of the grid.</li>\n<li><strong>voxel_size:</strong>  Voxel size of the grid.</li>\n<li><strong>dtype:</strong>  Data type of the created coordinate system.</li>\n<li><strong>device:</strong>  Device of the created coordinate system.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Centered coordinate system.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">voxel_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.voxel", "modulename": "composable_mapping", "qualname": "CoordinateSystem.voxel", "kind": "function", "doc": "<p>Create coordinate system corresponding to the voxel coordinate\npotentially scaled by the voxel size.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_shape:</strong>  Spatial shape of the grid.</li>\n<li><strong>voxel_size:</strong>  Voxel size of the grid.</li>\n<li><strong>dtype:</strong>  Data type of the created coordinate system.</li>\n<li><strong>device:</strong>  Device of the created coordinate system.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Voxel coordinate system.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">voxel_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.torch_grid_sample", "modulename": "composable_mapping", "qualname": "CoordinateSystem.torch_grid_sample", "kind": "function", "doc": "<p>Create coordinate system corresponding to the one used by the\ntorch.nn.functional.grid_sample.</p>\n\n<p>The coordinate system is normalized along each dimensions to the range\nfrom -1 to 1.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_shape:</strong>  Spatial shape of the grid.</li>\n<li><strong>fov_convention:</strong>  Convention for defining the field of view, either \"full_voxels\"\nor \"voxel_centers\". If voxels are seens as cubes with the value at the\ncenter, the convention \"full voxels\" includes the full cubes in the field\nof view, while the convention \"voxel_centers\" includes only the centers.\nThe latter results in a field of view that is one voxel smaller in each\ndimension. Similar to the align_corners option in\ntorch.nn.functional.grid_sample.</li>\n<li><strong>dtype:</strong>  Data type of the created coordinate system.</li>\n<li><strong>device:</strong>  Device of the created coordinate system.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Coordinate system corresponding to the one used by the\n  torch.nn.functional.grid_sample.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">fov_convention</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;full_voxels&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.from_affine_matrix", "modulename": "composable_mapping", "qualname": "CoordinateSystem.from_affine_matrix", "kind": "function", "doc": "<p>Create coordinate system from an affine matrix</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_shape:</strong>  Spatial shape of the grid</li>\n<li><strong>affine_matrix:</strong>  Affine matrix describing the transformation\nfrom voxel to world coordinates. Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1).\nThe affine matrix tensor should be provided on the host (cpu).\nThat is, since the transformation may be used in control flow\ndecisions, and we want to avoid synchronizing the target device\nwith the host. The matrix is moved to the target device\nasynchronously, if needed.</li>\n<li><strong>device:</strong>  Device of the created coordinate system.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Coordinate system with the given affine matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">affine_matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.from_diagonal_affine_matrix", "modulename": "composable_mapping", "qualname": "CoordinateSystem.from_diagonal_affine_matrix", "kind": "function", "doc": "<p>Create coordinate system from diagonal affine matrix</p>\n\n<p>The diagonal and the translation should be provided on the host (cpu).\nThat is, since the transformation may be used in control flow decisions,\nand we want to avoid synchronizing the target device with the host. The\nmatrix is moved to the target device asynchronously, if needed.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_shape:</strong>  Spatial shape of the created grid</li>\n<li><strong>diagonal:</strong>  Diagonal of the affine transformation matrix describing\nthe transformation from voxel to world coordinates. Tensor\nwith shape ([*batch_shape, ]diagonal_length[, *spatial_shape]).</li>\n<li><strong>translation:</strong>  Translation of the affine transformation describing\nthe transformation from voxel to world coordinates. Tensor with\nshape ([*batch_shape, ]n_output_dims[, *spatial_shape]).</li>\n<li><strong>dtype:</strong>  Data type of the created coordinate system.</li>\n<li><strong>device:</strong>  Device of the created coordinate system.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Coordinate system with the given diagonal affine matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">diagonal</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.coordinate_system", "modulename": "composable_mapping", "qualname": "CoordinateSystem.coordinate_system", "kind": "variable", "doc": "<p>Coordinate system of the container.</p>\n", "annotation": ": composable_mapping.coordinate_system.coordinate_system.CoordinateSystem"}, {"fullname": "composable_mapping.CoordinateSystem.forward", "modulename": "composable_mapping", "qualname": "CoordinateSystem.forward", "kind": "function", "doc": "<p>Dummy forward pass to make the coordinate system a torch.nn.Module</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.dtype", "modulename": "composable_mapping", "qualname": "CoordinateSystem.dtype", "kind": "variable", "doc": "<p>PyTorch data type.</p>\n", "annotation": ": torch.dtype"}, {"fullname": "composable_mapping.CoordinateSystem.device", "modulename": "composable_mapping", "qualname": "CoordinateSystem.device", "kind": "variable", "doc": "<p>PyTorch device.</p>\n", "annotation": ": torch.device"}, {"fullname": "composable_mapping.CoordinateSystem.from_voxel_coordinates", "modulename": "composable_mapping", "qualname": "CoordinateSystem.from_voxel_coordinates", "kind": "variable", "doc": "<p>Affine mapping from voxel to world coordinates</p>\n", "annotation": ": composable_mapping.affine_mapping.Affine"}, {"fullname": "composable_mapping.CoordinateSystem.to_voxel_coordinates", "modulename": "composable_mapping", "qualname": "CoordinateSystem.to_voxel_coordinates", "kind": "variable", "doc": "<p>Affine mapping from world to voxel coordinates</p>\n", "annotation": ": composable_mapping.affine_mapping.Affine"}, {"fullname": "composable_mapping.CoordinateSystem.spatial_shape", "modulename": "composable_mapping", "qualname": "CoordinateSystem.spatial_shape", "kind": "variable", "doc": "<p>Spatial shape of the coordinate system grid</p>\n", "annotation": ": Tuple[int, ...]"}, {"fullname": "composable_mapping.CoordinateSystem.grid", "modulename": "composable_mapping", "qualname": "CoordinateSystem.grid", "kind": "function", "doc": "<p>Grid in the world coordinates</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.voxel_grid", "modulename": "composable_mapping", "qualname": "CoordinateSystem.voxel_grid", "kind": "function", "doc": "<p>Grid in the voxel coordinates</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.grid_spacing_cpu", "modulename": "composable_mapping", "qualname": "CoordinateSystem.grid_spacing_cpu", "kind": "function", "doc": "<p>Obtain grid spacing as a CPU tensor</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.grid_spacing", "modulename": "composable_mapping", "qualname": "CoordinateSystem.grid_spacing", "kind": "function", "doc": "<p>Obtain grid spacing on the target device</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.transform_voxel", "modulename": "composable_mapping", "qualname": "CoordinateSystem.transform_voxel", "kind": "function", "doc": "<p>Transform the coordinates with an affine matrix in the\nvoxel coordinates before applying the current affine transformation</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>affine_matrix:</strong>  Affine matrix describing the transformation\nin the voxel coordinates. Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_spatial_dims + 1).\nThe affine matrix tensor should be provided on the host (cpu).\nThat is, since the transformation may be used in control flow\ndecisions, and we want to avoid synchronizing the target device\nwith the host. The matrix is moved to the target device\nasynchronously, if needed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Coordinate system with a modified affine transformation from voxel\n  to world coordinates.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">affine_matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.transform_voxel_with_diagonal_matrix", "modulename": "composable_mapping", "qualname": "CoordinateSystem.transform_voxel_with_diagonal_matrix", "kind": "function", "doc": "<p>Transform the coordinates with a diagonal affine matrix in the\nvoxel coordinates before applying the current affine transformation.</p>\n\n<p>The diagonal and the translation should be provided on the host (cpu).\nThat is, since the transformation may be used in control flow decisions,\nand we want to avoid synchronizing the target device with the host. The\nmatrix is moved to the target device asynchronously, if needed.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>diagonal:</strong>  Diagonal of the affine transformation matrix with shape\n([*batch_shape, ]n_spatial_dims). Can be also\ngiven as a number or sequence of numbers. If None, corresponds\nto the diagonal of ones.</li>\n<li><strong>translation:</strong>  Translation of the affine transformation matrix\nwith shape ([*batch_shape, ]n_spatial_dims).\nCan be also given as a number or sequence of numbers. If None,\ncorresponds to the zero translation.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Coordinate system with a modified affine transformation from voxel\n  to world coordinates.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">diagonal</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.transform_world", "modulename": "composable_mapping", "qualname": "CoordinateSystem.transform_world", "kind": "function", "doc": "<p>Transform the coordinates with an affine matrix in the\nworld coordinates after applying the current affine transformation</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>affine_matrix:</strong>  Affine matrix describing the transformation\nin the world coordinates. Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1).\nThe affine matrix tensor should be provided on the host (cpu).\nThat is, since the transformation may be used in control flow\ndecisions, and we want to avoid synchronizing the target device\nwith the host. The matrix is moved to the target device\nasynchronously, if needed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Coordinate system with a modified affine transformation from voxel\n  to world coordinates.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">affine_matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.transform_world_with_diagonal_matrix", "modulename": "composable_mapping", "qualname": "CoordinateSystem.transform_world_with_diagonal_matrix", "kind": "function", "doc": "<p>Transform the coordinates with a diagonal affine matrix in the\nworld coordinates after applying the current affine transformation</p>\n\n<p>The diagonal and the translation should be provided on the host (cpu).\nThat is, since the transformation may be used in control flow decisions,\nand we want to avoid synchronizing the target device with the host. The\nmatrix is moved to the target device asynchronously, if needed.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>diagonal:</strong>  Diagonal of the affine transformation matrix with shape\n([*batch_shape, ]diagonal_length). Can be also\ngiven as a number or sequence of numbers. If None, corresponds\nto the diagonal of ones.</li>\n<li><strong>translation:</strong>  Translation of the affine transformation matrix\nwith shape ([*batch_shape, ]n_output_dims).\nCan be also given as a number or sequence of numbers. If None,\ncorresponds to the zero translation.</li>\n<li><strong>n_output_dims:</strong>  Number of output dimensions of the transformation.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Coordinate system with a modified affine transformation from voxel\n  to world coordinates.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">diagonal</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_output_dims</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.translate_voxel", "modulename": "composable_mapping", "qualname": "CoordinateSystem.translate_voxel", "kind": "function", "doc": "<p>Translate the coordinates in the voxel coordinates before applying\nthe current affine transformation</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>translation:</strong>  Translation with shape ([*batch_shape, ]n_spatial_dims).\nCan be also given as a number or sequence of numbers.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Coordinate system with translated coordinates.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.translate_world", "modulename": "composable_mapping", "qualname": "CoordinateSystem.translate_world", "kind": "function", "doc": "<p>Translate the coordinates in the world coordinates after applying\nthe current affine transformation</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>translation:</strong>  Translation with shape ([*batch_shape, ]n_output_dims).\nCan be also given as a number or sequence of numbers.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.multiply_voxel", "modulename": "composable_mapping", "qualname": "CoordinateSystem.multiply_voxel", "kind": "function", "doc": "<p>Multiply the coordinates in the voxel coordinates (before applying\nthe current affine transformation)</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>factor:</strong>  Factor to multiply the grid spacing. A tensor with shape\n([*batch_shape, ]n_spatial_dims). Can be also given as a number\nor sequence of numbers.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Coordinate system with a modified affine transformation from voxel\n  to world coordinates.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">factor</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.multiply_world", "modulename": "composable_mapping", "qualname": "CoordinateSystem.multiply_world", "kind": "function", "doc": "<p>Multiply the coordinates in the world coordinates after applying\nthe current affine transformation.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>factor:</strong>  Factor to multiply each dimension of the grid. A tensor with\nshape ([*batch_shape, ]n_output_dims). Can be also given as a number\nor sequence of numbers.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Coordinate system with a modified affine transformation from voxel\n  to world coordinates.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">factor</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CoordinateSystem.reformat", "modulename": "composable_mapping", "qualname": "CoordinateSystem.reformat", "kind": "function", "doc": "<p>Reformat the coordinate system.</p>\n\n<p>All tensors should be provided on the host (cpu). That is, since the\ntransformation may be used in control flow decisions, and we want to\navoid synchronizing the target device with the host. The matrix is moved\nto the target device asynchronously, if needed.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>downsampling_factor:</strong>  Factor to downsample the grid voxel size. A tensor\nwith shape ([*batch_shape, ]n_spatial_dims). Can be also given as a\nnumber or sequence of numbers.</li>\n<li><strong>upsampling_factor:</strong>  Factor to upsample the grid voxel size. A tensor with\nshape ([*batch_shape, ]n_spatial_dims). Can be also given as a number\nor sequence of numbers.</li>\n<li><strong>voxel_size:</strong>  Voxel size of the reformatted grid. A tensor with shape\n([*batch_shape, ]n_spatial_dims). Can be also given as a number or\nsequence of numbers.</li>\n<li><strong>spatial_shape:</strong>  Defines spatial_shape of the target grid, either\ngiven separately for each dimension or as a single value in\nwhich case the same value is used for all the dimensions.\nDefaults to OriginalFOV(\"round\", \"full_voxels\").</li>\n<li><strong>reference:</strong>  Defines the point in the original voxel\ncoordinates which will be aligned with the target reference in\nthe reformatted coordinates. Either given separately for each\ndimension or as a single value in which case the same value is\nused for all the dimensions. Defaults to Center().</li>\n<li><strong>target_reference:</strong>  Defaults to reference. Defines the point in the\nreformatted voxel coordinates which will be aligned with the\nsource reference in the original coordinates. Either given\nseparately for each dimension or as a single value in which case\nthe same value is used for all the dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Reformatted coordinate system.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">downsampling_factor</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">upsampling_factor</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">voxel_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">reformatting_spatial_shape</span><span class=\"o\">.</span><span class=\"n\">ReformattingSpatialShape</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">reformatting_spatial_shape</span><span class=\"o\">.</span><span class=\"n\">ReformattingSpatialShape</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">reformatting_spatial_shape</span><span class=\"o\">.</span><span class=\"n\">OriginalFOV</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">reference</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">reformatting_reference</span><span class=\"o\">.</span><span class=\"n\">ReformattingReference</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">reformatting_reference</span><span class=\"o\">.</span><span class=\"n\">ReformattingReference</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">reformatting_reference</span><span class=\"o\">.</span><span class=\"n\">Center</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">target_reference</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">reformatting_reference</span><span class=\"o\">.</span><span class=\"n\">ReformattingReference</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">reformatting_reference</span><span class=\"o\">.</span><span class=\"n\">ReformattingReference</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CubicSplineSampler", "modulename": "composable_mapping", "qualname": "CubicSplineSampler", "kind": "class", "doc": "<p>Sampling based on regularly spaced cubic spline control points in voxel\ncoordinates</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>prefilter:</strong>  Whether to prefilter the volume before sampling making\nthe sampler an interpolator. Currently not implemented.</li>\n<li><strong>extrapolation_mode:</strong>  Extrapolation mode for out-of-bound coordinates.</li>\n<li><strong>mask_extrapolated_regions_for_empty_volume_mask:</strong>  Whether to mask\nextrapolated regions when input volume mask is empty.</li>\n<li><strong>convolution_threshold:</strong>  Maximum allowed difference in coordinates\nfor using convolution-based sampling (the difference might be upper\nbounded when doing the decision).</li>\n<li><strong>mask_threshold:</strong>  Maximum allowed weight for masked regions in a\nsampled location to still consider it valid (non-masked).</li>\n</ul>\n", "bases": "composable_mapping.sampler.base.BaseSeparableSampler"}, {"fullname": "composable_mapping.CubicSplineSampler.__init__", "modulename": "composable_mapping", "qualname": "CubicSplineSampler.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">prefilter</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">extrapolation_mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;border&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mask_extrapolated_regions_for_empty_volume_mask</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">convolution_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0001</span>,</span><span class=\"param\">\t<span class=\"n\">mask_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-05</span></span>)</span>"}, {"fullname": "composable_mapping.CubicSplineSampler.sample_values", "modulename": "composable_mapping", "qualname": "CubicSplineSampler.sample_values", "kind": "function", "doc": "<p>Sample values at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>volume:</strong>  Volume to sample over spatial dimensions\nwith shape (*batch_shape, *channels_shape, *spatial_shape)</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampled values with shape (*batch_shape, *channels_shape, *target_shape).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.CubicSplineSampler.sample_mask", "modulename": "composable_mapping", "qualname": "CubicSplineSampler.sample_mask", "kind": "function", "doc": "<p>Sample mask at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mask:</strong>  Mask to sample over spatial dimensions\nwith shape (*batch_shape, *(1,) * n_channel_dims, *spatial_shape).</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.DataFormat", "modulename": "composable_mapping", "qualname": "DataFormat", "kind": "class", "doc": "<p>Defines data format for sampled volumes.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>representation:</strong>  Representation of the data. Can be one of \"coordinates\"\nor \"displacements\".</li>\n<li><strong>coordinate_type:</strong>  Type of the coordinates. Can be one of \"world\" or\n\"voxel\".</li>\n</ul>\n"}, {"fullname": "composable_mapping.DataFormat.__init__", "modulename": "composable_mapping", "qualname": "DataFormat.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">representation</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">coordinate_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "composable_mapping.DataFormat.representation", "modulename": "composable_mapping", "qualname": "DataFormat.representation", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.DataFormat.coordinate_type", "modulename": "composable_mapping", "qualname": "DataFormat.coordinate_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.DataFormat.voxel_displacements", "modulename": "composable_mapping", "qualname": "DataFormat.voxel_displacements", "kind": "function", "doc": "<p>Voxel displacements data format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.DataFormat.world_displacements", "modulename": "composable_mapping", "qualname": "DataFormat.world_displacements", "kind": "function", "doc": "<p>World displacements data format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.DataFormat.voxel_coordinates", "modulename": "composable_mapping", "qualname": "DataFormat.voxel_coordinates", "kind": "function", "doc": "<p>Voxel coordinates data format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.DataFormat.world_coordinates", "modulename": "composable_mapping", "qualname": "DataFormat.world_coordinates", "kind": "function", "doc": "<p>World coordinates data format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.GenericSeparableDerivativeSampler", "modulename": "composable_mapping", "qualname": "GenericSeparableDerivativeSampler", "kind": "class", "doc": "<p>Sampler for sampling spatial derivatives of a separable kernel\nsampler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_dim:</strong>  Spatial dimension over which the derivative is taken.</li>\n<li><strong>parent_left_limit_kernel:</strong>  Parent sampler's left limit kernel function.</li>\n<li><strong>parent_right_limit_kernel:</strong>  Parent sampler's right limit kernel function.</li>\n<li><strong>parent_kernel_support:</strong>  Parent sampler's kernel support function.</li>\n<li><strong>parent_is_interpolating_kernel:</strong>  Parent sampler's information on whether the kernel\nis interpolating.</li>\n<li><strong>limit_direction:</strong>  Direction for evaluating the kernel at discontinuous points.</li>\n<li><strong>extrapolation_mode:</strong>  Extrapolation mode for out-of-bound coordinates.</li>\n<li><strong>mask_extrapolated_regions_for_empty_volume_mask:</strong>  Whether to mask\nextrapolated regions when input volume mask is empty.</li>\n<li><strong>convolution_threshold:</strong>  Maximum allowed difference in coordinates\nfor using convolution-based sampling.</li>\n<li><strong>mask_threshold:</strong>  Maximum allowed weight for masked regions in a\nsampled location to still consider it valid (non-masked).</li>\n</ul>\n", "bases": "composable_mapping.sampler.base.BaseSeparableSampler"}, {"fullname": "composable_mapping.GenericSeparableDerivativeSampler.__init__", "modulename": "composable_mapping", "qualname": "GenericSeparableDerivativeSampler.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spatial_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">parent_left_limit_kernel</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">parent_right_limit_kernel</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">parent_kernel_support</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">ISeparableKernelSupport</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">parent_is_interpolating_kernel</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">limit_direction</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">extrapolation_mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;border&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mask_extrapolated_regions_for_empty_volume_mask</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">convolution_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0001</span>,</span><span class=\"param\">\t<span class=\"n\">mask_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-05</span></span>)</span>"}, {"fullname": "composable_mapping.GenericSeparableDerivativeSampler.derivative", "modulename": "composable_mapping", "qualname": "GenericSeparableDerivativeSampler.derivative", "kind": "function", "doc": "<p>Obtain sampler for sampling derivatives corresponding to the current sampler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_dim:</strong>  Spatial dimension along which to compute the derivative.</li>\n<li><strong>limit_direction:</strong>  Direction in which to compute the derivative.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampler for sampling derivatives.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">limit_direction</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">GenericSeparableDerivativeSampler</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.GenericSeparableDerivativeSampler.sample_values", "modulename": "composable_mapping", "qualname": "GenericSeparableDerivativeSampler.sample_values", "kind": "function", "doc": "<p>Sample values at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>volume:</strong>  Volume to sample over spatial dimensions\nwith shape (*batch_shape, *channels_shape, *spatial_shape)</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampled values with shape (*batch_shape, *channels_shape, *target_shape).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.GenericSeparableDerivativeSampler.sample_mask", "modulename": "composable_mapping", "qualname": "GenericSeparableDerivativeSampler.sample_mask", "kind": "function", "doc": "<p>Sample mask at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mask:</strong>  Mask to sample over spatial dimensions\nwith shape (*batch_shape, *(1,) * n_channel_dims, *spatial_shape).</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.GridComposableMapping", "modulename": "composable_mapping", "qualname": "GridComposableMapping", "kind": "class", "doc": "<p>Base class for composable mappings with an assigned coordinate system.</p>\n", "bases": "composable_mapping.composable_mapping.composable_mapping.ComposableMapping, composable_mapping.composable_mapping.interface.ICoordinateSystemContainer, abc.ABC"}, {"fullname": "composable_mapping.GridComposableMapping.invert", "modulename": "composable_mapping", "qualname": "GridComposableMapping.invert", "kind": "function", "doc": "<p>Invert the mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arguments:</strong>  Arguments for the inversion.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The inverted mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">arguments</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">GridComposableMapping</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.GridComposableMapping.sample", "modulename": "composable_mapping", "qualname": "GridComposableMapping.sample", "kind": "function", "doc": "<p>Evaluate the mapping at the coordinates contained by the mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data_format:</strong>  Data format of the output. Default data format depends\non the mapping, but as a general rule is the same as the data\nformat of the mapping being sampled, or the default data format\nof the left mapping in a composition or other operation. When no\nclear default data format is available,\nDataFormat.world_coordinates() is used. Default data format can\nbe set for a mapping using <code>set_default_sampling_data_format</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Mappable tensor containing the values obtained by evaluating the\n  mapping at the coordinates contained by the mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data_format</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.GridComposableMapping.resample", "modulename": "composable_mapping", "qualname": "GridComposableMapping.resample", "kind": "function", "doc": "<p>Resample the mapping at the coordinates contained by the mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data_format:</strong>  Data format used as an internal representation of the\ngenerated resampled mapping. Default data format depends on the\nmapping, but as a general rule is the same as the data format of\nthe mapping being sampled, or the default data format of the\nleft mapping in a composition or other operation. When no clear\ndefault data format is available, DataFormat.world_coordinates()\nis used. Default data format can be set for a mapping using\n<code>set_default_sampling_data_format</code>.</li>\n<li><strong>sampler:</strong>  Sampler used by the generated resampled mapping. Note that\nthis sampler is not used to resample the mapping, but to sample\nthe generated resampled mapping. If None, the default sampler\nis used (see <code>default_sampler</code>).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Resampled mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data_format</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">sampler</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">SamplableVolume</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.GridVisualizationArguments", "modulename": "composable_mapping", "qualname": "GridVisualizationArguments", "kind": "class", "doc": "<p>Arguments for grid visualization</p>\n"}, {"fullname": "composable_mapping.GridVisualizationArguments.__init__", "modulename": "composable_mapping", "qualname": "GridVisualizationArguments.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">batch_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">figure_height</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">emphasize_every_nth_line</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">plot_kwargs</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Mapping</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "composable_mapping.GridVisualizationArguments.batch_index", "modulename": "composable_mapping", "qualname": "GridVisualizationArguments.batch_index", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.GridVisualizationArguments.figure_height", "modulename": "composable_mapping", "qualname": "GridVisualizationArguments.figure_height", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.GridVisualizationArguments.emphasize_every_nth_line", "modulename": "composable_mapping", "qualname": "GridVisualizationArguments.emphasize_every_nth_line", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.GridVisualizationArguments.plot_kwargs", "modulename": "composable_mapping", "qualname": "GridVisualizationArguments.plot_kwargs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.Identity", "modulename": "composable_mapping", "qualname": "Identity", "kind": "class", "doc": "<p>Identity mapping.</p>\n", "bases": "composable_mapping.tensor_like.BaseTensorLikeWrapper, composable_mapping.composable_mapping.composable_mapping.ComposableMapping"}, {"fullname": "composable_mapping.Identity.invert", "modulename": "composable_mapping", "qualname": "Identity.invert", "kind": "function", "doc": "<p>Invert the mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arguments:</strong>  Arguments for the inversion.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The inverted mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">_inversion_parameters</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">Identity</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.Identity.detach", "modulename": "composable_mapping", "qualname": "Identity.detach", "kind": "function", "doc": "<p>Detach the wrapped tensors from computational graph.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">Identity</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ISampler", "modulename": "composable_mapping", "qualname": "ISampler", "kind": "class", "doc": "<p>Samples values on regular grid in voxel coordinates.</p>\n", "bases": "abc.ABC"}, {"fullname": "composable_mapping.ISampler.derivative", "modulename": "composable_mapping", "qualname": "ISampler.derivative", "kind": "function", "doc": "<p>Obtain sampler for sampling derivatives corresponding to the current sampler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_dim:</strong>  Spatial dimension along which to compute the derivative.</li>\n<li><strong>limit_direction:</strong>  Direction in which to compute the derivative.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampler for sampling derivatives.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">limit_direction</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ISampler.inverse", "modulename": "composable_mapping", "qualname": "ISampler.inverse", "kind": "function", "doc": "<p>Obtain sampler for sampling inverse values corresponding to the\ncurrent sampler, if available.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>coordinate_system:</strong>  Coordinate system of the mapping.</li>\n<li><strong>data_format:</strong>  Data format of the sampled volume.</li>\n<li><strong>arguments:</strong>  Additional arguments for the inverse.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampler for sampling inverse values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">coordinate_system</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>,</span><span class=\"param\">\t<span class=\"n\">data_format</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span>,</span><span class=\"param\">\t<span class=\"n\">arguments</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Mapping</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ISampler.sample_values", "modulename": "composable_mapping", "qualname": "ISampler.sample_values", "kind": "function", "doc": "<p>Sample values at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>volume:</strong>  Volume to sample over spatial dimensions\nwith shape (*batch_shape, *channels_shape, *spatial_shape)</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampled values with shape (*batch_shape, *channels_shape, *target_shape).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ISampler.sample_mask", "modulename": "composable_mapping", "qualname": "ISampler.sample_mask", "kind": "function", "doc": "<p>Sample mask at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mask:</strong>  Mask to sample over spatial dimensions\nwith shape (*batch_shape, *(1,) * n_channel_dims, *spatial_shape).</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ImageVisualizationArguments", "modulename": "composable_mapping", "qualname": "ImageVisualizationArguments", "kind": "class", "doc": "<p>Arguments for image visualization</p>\n"}, {"fullname": "composable_mapping.ImageVisualizationArguments.__init__", "modulename": "composable_mapping", "qualname": "ImageVisualizationArguments.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">batch_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">figure_height</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">mask_color</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#591500&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">vmin</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">vmax</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">imshow_kwargs</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Mapping</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "composable_mapping.ImageVisualizationArguments.batch_index", "modulename": "composable_mapping", "qualname": "ImageVisualizationArguments.batch_index", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.ImageVisualizationArguments.figure_height", "modulename": "composable_mapping", "qualname": "ImageVisualizationArguments.figure_height", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.ImageVisualizationArguments.mask_color", "modulename": "composable_mapping", "qualname": "ImageVisualizationArguments.mask_color", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.ImageVisualizationArguments.vmin", "modulename": "composable_mapping", "qualname": "ImageVisualizationArguments.vmin", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.ImageVisualizationArguments.vmax", "modulename": "composable_mapping", "qualname": "ImageVisualizationArguments.vmax", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.ImageVisualizationArguments.imshow_kwargs", "modulename": "composable_mapping", "qualname": "ImageVisualizationArguments.imshow_kwargs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.LimitDirection", "modulename": "composable_mapping", "qualname": "LimitDirection", "kind": "class", "doc": "<p>Direction of a limit.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>direction:</strong>  Direction of the limit. Can be one of \"left\", \"right\", or\n\"average\".</li>\n</ul>\n"}, {"fullname": "composable_mapping.LimitDirection.__init__", "modulename": "composable_mapping", "qualname": "LimitDirection.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">direction</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "composable_mapping.LimitDirection.direction", "modulename": "composable_mapping", "qualname": "LimitDirection.direction", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.LimitDirection.left", "modulename": "composable_mapping", "qualname": "LimitDirection.left", "kind": "function", "doc": "<p>Left limit direction.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.LimitDirection.right", "modulename": "composable_mapping", "qualname": "LimitDirection.right", "kind": "function", "doc": "<p>Right limit direction.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.LimitDirection.average", "modulename": "composable_mapping", "qualname": "LimitDirection.average", "kind": "function", "doc": "<p>Average of left and right limit directions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.LimitDirection.as_callable", "modulename": "composable_mapping", "qualname": "LimitDirection.as_callable", "kind": "function", "doc": "<p>Limit direction as callable.</p>\n\n<p>Useful for creating a callable that returns the same limit direction\nfor all dimensions.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.LinearInterpolator", "modulename": "composable_mapping", "qualname": "LinearInterpolator", "kind": "class", "doc": "<p>Linear interpolation in voxel coordinates</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>extrapolation_mode:</strong>  Extrapolation mode for out-of-bound coordinates.</li>\n<li><strong>mask_extrapolated_regions_for_empty_volume_mask:</strong>  Whether to mask\nextrapolated regions when input volume mask is empty.</li>\n<li><strong>convolution_threshold:</strong>  Maximum allowed difference in coordinates\nfor using convolution-based sampling (the difference might be upper\nbounded when doing the decision).</li>\n<li><strong>mask_threshold:</strong>  Maximum allowed weight for masked regions in a\nsampled location to still consider it valid (non-masked).</li>\n</ul>\n", "bases": "composable_mapping.sampler.base.BaseSeparableSampler"}, {"fullname": "composable_mapping.LinearInterpolator.__init__", "modulename": "composable_mapping", "qualname": "LinearInterpolator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">extrapolation_mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;border&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mask_extrapolated_regions_for_empty_volume_mask</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">convolution_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0001</span>,</span><span class=\"param\">\t<span class=\"n\">mask_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-05</span></span>)</span>"}, {"fullname": "composable_mapping.LinearInterpolator.sample_values", "modulename": "composable_mapping", "qualname": "LinearInterpolator.sample_values", "kind": "function", "doc": "<p>Sample values at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>volume:</strong>  Volume to sample over spatial dimensions\nwith shape (*batch_shape, *channels_shape, *spatial_shape)</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampled values with shape (*batch_shape, *channels_shape, *target_shape).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.LinearInterpolator.sample_mask", "modulename": "composable_mapping", "qualname": "LinearInterpolator.sample_mask", "kind": "function", "doc": "<p>Sample mask at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mask:</strong>  Mask to sample over spatial dimensions\nwith shape (*batch_shape, *(1,) * n_channel_dims, *spatial_shape).</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.MappableTensor", "modulename": "composable_mapping", "qualname": "MappableTensor", "kind": "class", "doc": "<p>A tensor wrapper used as inputs for composable mappings</p>\n\n<p>It is not recommended to create instances of this class directly, but to\nuse instead the constructors provided in the module, or as class methods\nof this class: <code>mappable</code>, <code>voxel_grid</code>, <code>MappableTensor.from_tensor</code>,\n<code>MappableTensor.voxel_grid</code>.</p>\n\n<p>The core idea of the mappable tensor is that affine transformations applied\nto the tensor are not applied right away, but only when the values are\ngenerated. This allows for more efficient computation. Additionally,\nrepresenting voxel coordinate grids and their transformations without\ngenerating the grid is possible. Such grids can be also combined with\ndisplacement vectors, still without generating the grid.</p>\n\n<p>Masks can also be used to define valid regions of the tensor.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>displacements:</strong>  Displacement vectors, tensor with shape\n(*batch_shape, *channels_shape, *spatial_shape).</li>\n<li><strong>mask:</strong>  Mask of the tensor with shape (*batch_shape, *(1,) *\nn_channel_dims, *spatial_shape).</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n<li><strong>affine_transformation:</strong>  Affine transformation acting on the displacements.</li>\n<li><strong>grid:</strong>  Definition of a grid added to the displacements.</li>\n</ul>\n", "bases": "composable_mapping.tensor_like.BaseTensorLikeWrapper"}, {"fullname": "composable_mapping.MappableTensor.__init__", "modulename": "composable_mapping", "qualname": "MappableTensor.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">displacements</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">affine_transformation</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IAffineTransformation</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">grid</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">grid</span><span class=\"o\">.</span><span class=\"n\">GridDefinition</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "composable_mapping.MappableTensor.from_tensor", "modulename": "composable_mapping", "qualname": "MappableTensor.from_tensor", "kind": "function", "doc": "<p>Create a mappable tensor from values and mask</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>values:</strong>  Values of the generated mappable tensor, tensor with shape\n(*batch_shape, *channels_shape, *spatial_shape).</li>\n<li><strong>mask:</strong>  Mask of the generated mapable tensor with shape\n(*batch_shape, *(1,) * n_channel_dims, *spatial_shape).</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Mappable tensor.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.MappableTensor.voxel_grid", "modulename": "composable_mapping", "qualname": "MappableTensor.voxel_grid", "kind": "function", "doc": "<p>Create a voxel grid with optional mask.</p>\n\n<p>The voxel grid is not generated explicitly right away, but only when the\nvalues are generated.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_shape:</strong>  Spatial shape of the created grid.</li>\n<li><strong>mask:</strong>  Mask of the grid with shape\n(*batch_shape, *(1,) * n_channel_dims, *spatial_shape).</li>\n<li><strong>dtype:</strong>  Data type of the grid.</li>\n<li><strong>device:</strong>  Device of the grid.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Mappable tensor representing the voxel grid.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.MappableTensor.shape", "modulename": "composable_mapping", "qualname": "MappableTensor.shape", "kind": "variable", "doc": "<p>Shape of the mappable tensor</p>\n", "annotation": ": Tuple[int, ...]"}, {"fullname": "composable_mapping.MappableTensor.spatial_shape", "modulename": "composable_mapping", "qualname": "MappableTensor.spatial_shape", "kind": "variable", "doc": "<p>Spatial shape of the mappable tensor</p>\n", "annotation": ": Tuple[int, ...]"}, {"fullname": "composable_mapping.MappableTensor.channels_shape", "modulename": "composable_mapping", "qualname": "MappableTensor.channels_shape", "kind": "variable", "doc": "<p>Channel shape of the mappable tensor</p>\n", "annotation": ": Tuple[int, ...]"}, {"fullname": "composable_mapping.MappableTensor.batch_shape", "modulename": "composable_mapping", "qualname": "MappableTensor.batch_shape", "kind": "variable", "doc": "<p>Batch shape of the mappable tensor.</p>\n", "annotation": ": Tuple[int, ...]"}, {"fullname": "composable_mapping.MappableTensor.mask_shape", "modulename": "composable_mapping", "qualname": "MappableTensor.mask_shape", "kind": "variable", "doc": "<p>Shape of the generated mask of the mappable tensor</p>\n", "annotation": ": Tuple[int, ...]"}, {"fullname": "composable_mapping.MappableTensor.n_channel_dims", "modulename": "composable_mapping", "qualname": "MappableTensor.n_channel_dims", "kind": "variable", "doc": "<p>Number of channel dimensions</p>\n", "annotation": ": int"}, {"fullname": "composable_mapping.MappableTensor.generate", "modulename": "composable_mapping", "qualname": "MappableTensor.generate", "kind": "function", "doc": "<p>Generate values and mask contained by the mappable tensor.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>generate_mask:</strong>  Generate mask of ones if the tensor does not contain an explicit mask.</li>\n<li><strong>cast_mask:</strong>  Mask is stored as a boolean tensor, cast it to dtype of values if True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple of values and mask.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">generate_missing_mask</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">cast_mask</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.MappableTensor.generate_values", "modulename": "composable_mapping", "qualname": "MappableTensor.generate_values", "kind": "function", "doc": "<p>Generate values contained by the mappable tensor.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.MappableTensor.generate_mask", "modulename": "composable_mapping", "qualname": "MappableTensor.generate_mask", "kind": "function", "doc": "<p>Generate mask contained by the mappable tensor.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>generate_mask:</strong>  Generate mask of ones if the tensor does not contain an explicit mask.</li>\n<li><strong>cast_mask:</strong>  Mask is stored as a boolean tensor, cast it to dtype of values if True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Mask of the mappable tensor.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">generate_missing_mask</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">cast_mask</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.MappableTensor.displacements", "modulename": "composable_mapping", "qualname": "MappableTensor.displacements", "kind": "variable", "doc": "<p>Displacements contained by the mappable tensor</p>\n\n<p>The displacements vector might not have the same shape as the mappable\ntensor, but is brodcastable to it. This is a relatively low level\nproperty and the recommended way to access the values is through the\n<code>generate_values</code> method.</p>\n", "annotation": ": Union[torch.Tensor, NoneType]"}, {"fullname": "composable_mapping.MappableTensor.affine_transformation", "modulename": "composable_mapping", "qualname": "MappableTensor.affine_transformation", "kind": "variable", "doc": "<p>Affine transformation on displacements, if available</p>\n\n<p>This is relatively low level property, and should be used with caution.</p>\n", "annotation": ": Union[composable_mapping.affine_transformation.affine_transformation.IAffineTransformation, NoneType]"}, {"fullname": "composable_mapping.MappableTensor.grid", "modulename": "composable_mapping", "qualname": "MappableTensor.grid", "kind": "variable", "doc": "<p>Definition of the grid contained by the tensor, if available</p>\n\n<p>The grid might not have the same shape as the mappable tensor, but is\nbrodcastable to it. This is relatively low level method, and should be\nused with caution.</p>\n", "annotation": ": Union[composable_mapping.mappable_tensor.grid.GridDefinition, NoneType]"}, {"fullname": "composable_mapping.MappableTensor.transform", "modulename": "composable_mapping", "qualname": "MappableTensor.transform", "kind": "function", "doc": "<p>Apply an affine transformation to the last channel dimension of the\nmappable tensor.</p>\n\n<p>The affine transformation is not applied right a way, only the\ncomposition with the existing affine transformation is stored. The\ntransformation is applied when the values are generated.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>affine_transformation:</strong>  Affine transformation to apply.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Transformed mappable tensor.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">affine_transformation</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IAffineTransformation</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.MappableTensor.has_mask", "modulename": "composable_mapping", "qualname": "MappableTensor.has_mask", "kind": "function", "doc": "<p>Has the mappable tensor an explicit mask</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.MappableTensor.clear_mask", "modulename": "composable_mapping", "qualname": "MappableTensor.clear_mask", "kind": "function", "doc": "<p>Clear mask from the mappable tensor</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.MappableTensor.reduce", "modulename": "composable_mapping", "qualname": "MappableTensor.reduce", "kind": "function", "doc": "<p>Reduce the masked tensor to a mappable tensor with values and mask\nstored explicitly.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.MappableTensor.modify_values", "modulename": "composable_mapping", "qualname": "MappableTensor.modify_values", "kind": "function", "doc": "<p>Modify values of the mappable tensor.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>values:</strong>  New values of the mappable tensor. Tensor with shape\n(*batch_shape, *channels_shape, *spatial_shape).</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions of the new values.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.MappableTensor.mask_and", "modulename": "composable_mapping", "qualname": "MappableTensor.mask_and", "kind": "function", "doc": "<p>Combine mask with logical and.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mask:</strong>  Mask to combine with the mappable tensor.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Mappable tensor with the combined mask.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.MappableTensor.modify_mask", "modulename": "composable_mapping", "qualname": "MappableTensor.modify_mask", "kind": "function", "doc": "<p>Modify mask of the mappable tensor.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mask:</strong>  New mask of the mappable tensor.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Mappable tensor with the new mask.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.NearestInterpolator", "modulename": "composable_mapping", "qualname": "NearestInterpolator", "kind": "class", "doc": "<p>Nearest neighbour interpolation in voxel coordinates.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>extrapolation_mode:</strong>  Extrapolation mode for out-of-bound coordinates.</li>\n<li><strong>mask_extrapolated_regions_for_empty_volume_mask:</strong>  Whether to mask\nextrapolated regions when input volume mask is empty.</li>\n<li><strong>convolution_threshold:</strong>  Maximum allowed difference in coordinates\nfor using convolution-based sampling (the difference might be upper\nbounded when doing the decision).</li>\n<li><strong>mask_threshold:</strong>  Maximum allowed weight for masked regions in a\nsampled location to still consider it valid (non-masked).</li>\n<li><strong>limit_direction:</strong>  How to handle points at equal distances. This\noption currently applies only to convolution based sampling.</li>\n</ul>\n", "bases": "composable_mapping.sampler.base.BaseSeparableSampler"}, {"fullname": "composable_mapping.NearestInterpolator.__init__", "modulename": "composable_mapping", "qualname": "NearestInterpolator.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">extrapolation_mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;border&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mask_extrapolated_regions_for_empty_volume_mask</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">convolution_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0001</span>,</span><span class=\"param\">\t<span class=\"n\">mask_threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-05</span>,</span><span class=\"param\">\t<span class=\"n\">limit_direction</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "composable_mapping.NearestInterpolator.sample_values", "modulename": "composable_mapping", "qualname": "NearestInterpolator.sample_values", "kind": "function", "doc": "<p>Sample values at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>volume:</strong>  Volume to sample over spatial dimensions\nwith shape (*batch_shape, *channels_shape, *spatial_shape)</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampled values with shape (*batch_shape, *channels_shape, *target_shape).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.NearestInterpolator.sample_mask", "modulename": "composable_mapping", "qualname": "NearestInterpolator.sample_mask", "kind": "function", "doc": "<p>Sample mask at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mask:</strong>  Mask to sample over spatial dimensions\nwith shape (*batch_shape, *(1,) * n_channel_dims, *spatial_shape).</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.Number", "modulename": "composable_mapping", "qualname": "Number", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Union[int, float]"}, {"fullname": "composable_mapping.OriginalFOV", "modulename": "composable_mapping", "qualname": "OriginalFOV", "kind": "class", "doc": "<p>Spatial shape such that the size of the field of view is the same as with\nthe original grid.</p>\n\n<p>E.g. if the original grid has a size of 10 and the downsampling factor is 2,\nthe target size will be 5 (with fov_convention == \"full_voxels\").</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fitting_method:</strong>  Method for fitting the field of view size, either \"round\",\n\"floor\", or \"ceil\".</li>\n<li><strong>fov_convention:</strong>  Convention for defining the field of view, either \"full_voxels\"\nor \"voxel_centers\". If voxels are seens as cubes with the value at the\ncenter, the convention \"full voxels\" includes the full cubes in the field\nof view, while the convention \"voxel_centers\" includes only the centers.\nThe latter results in a field of view that is one voxel smaller in each\ndimension. Similar to the align_corners option in\ntorch.nn.functional.grid_sample</li>\n</ul>\n", "bases": "composable_mapping.coordinate_system.reformatting_spatial_shape.ReformattingSpatialShape"}, {"fullname": "composable_mapping.OriginalFOV.__init__", "modulename": "composable_mapping", "qualname": "OriginalFOV.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fitting_method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;round&#39;</span>, </span><span class=\"param\"><span class=\"n\">fov_convention</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;full_voxels&#39;</span></span>)</span>"}, {"fullname": "composable_mapping.OriginalFOV.DIVISION_FUNCTIONS", "modulename": "composable_mapping", "qualname": "OriginalFOV.DIVISION_FUNCTIONS", "kind": "variable", "doc": "<p></p>\n", "default_value": "{&#x27;round&#x27;: &lt;function OriginalFOV.&lt;lambda&gt;&gt;, &#x27;floor&#x27;: &lt;function OriginalFOV.&lt;lambda&gt;&gt;, &#x27;ceil&#x27;: &lt;function OriginalFOV.&lt;lambda&gt;&gt;}"}, {"fullname": "composable_mapping.OriginalFOV.target_size", "modulename": "composable_mapping", "qualname": "OriginalFOV.target_size", "kind": "function", "doc": "<p>Return a target size given an original size and a downsampling factor.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>original_size:</strong>  Original size of the dimension.</li>\n<li><strong>downsampling_factor:</strong>  Downsampling factor of the dimension during reformatting.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Target size of the dimension.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">original_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">downsampling_factor</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.OriginalShape", "modulename": "composable_mapping", "qualname": "OriginalShape", "kind": "class", "doc": "<p>Spatial shape of the original grid.</p>\n", "bases": "composable_mapping.coordinate_system.reformatting_spatial_shape.ReformattingSpatialShape"}, {"fullname": "composable_mapping.OriginalShape.target_size", "modulename": "composable_mapping", "qualname": "OriginalShape.target_size", "kind": "function", "doc": "<p>Return a target size given an original size and a downsampling factor.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>original_size:</strong>  Original size of the dimension.</li>\n<li><strong>downsampling_factor:</strong>  Downsampling factor of the dimension during reformatting.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Target size of the dimension.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">original_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">downsampling_factor</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ReformattingReference", "modulename": "composable_mapping", "qualname": "ReformattingReference", "kind": "class", "doc": "<p>Reference point which will be aligned between the\noriginal and the reformatted coordinates.</p>\n\n<p>Allows to define the reference point for reformatting based on the\nspatial size of the grid.</p>\n\n<p>For ease of use, the class implements the basic arithmetic operators\nto allow for easy manipulation of the reference point.</p>\n", "bases": "abc.ABC"}, {"fullname": "composable_mapping.ReformattingReference.get_voxel_coordinate", "modulename": "composable_mapping", "qualname": "ReformattingReference.get_voxel_coordinate", "kind": "function", "doc": "<p>Get a voxel coordinate corresponding to the reference position with\na given dimension size.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>size:</strong>  Size of the dimension</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Voxel coordinate corresponding to the reference position along the dimension.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">size</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ReformattingSpatialShape", "modulename": "composable_mapping", "qualname": "ReformattingSpatialShape", "kind": "class", "doc": "<p>Instances of this class can be used as target spatial shapes for reformatting\ncoordinate systems.</p>\n\n<p>Allows to define how the spatial shape of the grid should be reformatted based on\nthe original spatial shape and the downsampling factor.</p>\n\n<p>For ease of use, the class implements the basic arithmetic operators to allow for\neasy manipulation of the spatial shape.</p>\n", "bases": "abc.ABC"}, {"fullname": "composable_mapping.ReformattingSpatialShape.target_size", "modulename": "composable_mapping", "qualname": "ReformattingSpatialShape.target_size", "kind": "function", "doc": "<p>Return a target size given an original size and a downsampling factor.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>original_size:</strong>  Original size of the dimension.</li>\n<li><strong>downsampling_factor:</strong>  Downsampling factor of the dimension during reformatting.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Target size of the dimension.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">original_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">downsampling_factor</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.RectangleMask", "modulename": "composable_mapping", "qualname": "RectangleMask", "kind": "class", "doc": "<p>Modify mask of the input based on bounds</p>\n\n<p>Arguments.\n    min_values: Minimum values for the mask over each dimension.\n    max_values: Maximum values for the mask over each dimension.\n    inclusive_min: Whether the minimum values are inclusive.\n    inclusive_max: Whether the maximum values are inclusive</p>\n", "bases": "composable_mapping.tensor_like.BaseTensorLikeWrapper, composable_mapping.composable_mapping.composable_mapping.ComposableMapping"}, {"fullname": "composable_mapping.RectangleMask.__init__", "modulename": "composable_mapping", "qualname": "RectangleMask.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">min_values</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">max_values</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">inclusive_min</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inclusive_max</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span>)</span>"}, {"fullname": "composable_mapping.RectangleMask.invert", "modulename": "composable_mapping", "qualname": "RectangleMask.invert", "kind": "function", "doc": "<p>Invert the mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arguments:</strong>  Arguments for the inversion.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The inverted mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">arguments</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.RectangleMask.detach", "modulename": "composable_mapping", "qualname": "RectangleMask.detach", "kind": "function", "doc": "<p>Detach the wrapped tensors from computational graph.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mask</span><span class=\"o\">.</span><span class=\"n\">RectangleMask</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.SamplableVolume", "modulename": "composable_mapping", "qualname": "SamplableVolume", "kind": "class", "doc": "<p>Mapping defined based on a regular grid of values and a sampler turning the\ngrid values into a continuously defined mapping.</p>\n\n<p>The easiest way to create a samplable volume is to use the factory\nfunction provided in this module or the class method of this class:\n<code>samplable_volume</code>, <code>SamplableVolume.from_tensor</code>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Regular grid of values, with shape\n(*batch_shape, *channels_shape, *spatial_shape).</li>\n<li><strong>coordinate_system:</strong>  Coordinate system describing transformation from the\nvoxel coordinates on the data grid to the world coordinates.</li>\n<li><strong>data_format:</strong>  Data format of the grid values.</li>\n<li><strong>sampler:</strong>  Sampler turning the grid values into a continuously defined mapping\nover spatial coordinates.</li>\n</ul>\n", "bases": "composable_mapping.tensor_like.BaseTensorLikeWrapper, composable_mapping.composable_mapping.composable_mapping.GridComposableMapping"}, {"fullname": "composable_mapping.SamplableVolume.__init__", "modulename": "composable_mapping", "qualname": "SamplableVolume.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>,</span><span class=\"param\">\t<span class=\"n\">coordinate_system</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>,</span><span class=\"param\">\t<span class=\"n\">data_format</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span> <span class=\"o\">=</span> <span class=\"n\">DataFormat</span><span class=\"p\">(</span><span class=\"n\">representation</span><span class=\"o\">=</span><span class=\"n\">coordinates</span><span class=\"p\">,</span> <span class=\"n\">coordinate_type</span><span class=\"o\">=</span><span class=\"n\">world</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">sampler</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "composable_mapping.SamplableVolume.from_tensor", "modulename": "composable_mapping", "qualname": "SamplableVolume.from_tensor", "kind": "function", "doc": "<p>Create a samplable volume from a tensor.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data:</strong>  Regular grid of values, with shape\n(*batch_shape, *channels_shape, *spatial_shape).</li>\n<li><strong>coordinate_system:</strong>  Coordinate system describing transformation from the\nvoxel coordinates on the data grid to the world coordinates.</li>\n<li><strong>mask:</strong>  Mask for the data,\nwith shape (*batch_shape, *(1,) * n_channel_dims, *spatial_shape).</li>\n<li><strong>data_format:</strong>  Data format of the grid values.</li>\n<li><strong>sampler:</strong>  Sampler turning the grid values into a continuously defined mapping\nover spatial coordinates.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Samplable volume.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">coordinate_system</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">data_format</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span> <span class=\"o\">=</span> <span class=\"n\">DataFormat</span><span class=\"p\">(</span><span class=\"n\">representation</span><span class=\"o\">=</span><span class=\"n\">coordinates</span><span class=\"p\">,</span> <span class=\"n\">coordinate_type</span><span class=\"o\">=</span><span class=\"n\">world</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">sampler</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.SamplableVolume.modify_sampler", "modulename": "composable_mapping", "qualname": "SamplableVolume.modify_sampler", "kind": "function", "doc": "<p>Modify the sampler of the volume.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sampler:</strong>  New sampler.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Samplable volume with the new sampler.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">sampler</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">SamplableVolume</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.SamplableVolume.coordinate_system", "modulename": "composable_mapping", "qualname": "SamplableVolume.coordinate_system", "kind": "variable", "doc": "<p>Coordinate system of the container.</p>\n", "annotation": ": composable_mapping.coordinate_system.coordinate_system.CoordinateSystem"}, {"fullname": "composable_mapping.SamplableVolume.default_sampling_data_format", "modulename": "composable_mapping", "qualname": "SamplableVolume.default_sampling_data_format", "kind": "variable", "doc": "<p>Default data format to use in sampling and resampling operations for\nthe mapping.</p>\n\n<p>If None, DataFormat.world_coordinates() will be used but the behaviour\nin operations with other mappings is different as the default data format\nof the other mapping will be used.</p>\n", "annotation": ": composable_mapping.sampler.interface.DataFormat"}, {"fullname": "composable_mapping.SamplableVolume.invert", "modulename": "composable_mapping", "qualname": "SamplableVolume.invert", "kind": "function", "doc": "<p>Invert the mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arguments:</strong>  Arguments for the inversion.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The inverted mapping.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">arguments</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">SamplableVolume</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ScalingAndSquaring", "modulename": "composable_mapping", "qualname": "ScalingAndSquaring", "kind": "class", "doc": "<p>Scaling and squaring sampler.</p>\n\n<p>Applies scaling and squaring to integrate stationary velocity field (SVF) before\nsampling the volume.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sampler:</strong>  Sampler used in integration of the SVF and sampling the volume.</li>\n<li><strong>steps:</strong>  Number of scaling and squaring steps.</li>\n<li><strong>inverse:</strong>  Whether to integrate in the inverse direction.</li>\n<li><strong>mask_extrapolated_regions_for_empty_volume_mask:</strong>  Whether to mask\nextrapolated regions when input volume mask is empty.</li>\n</ul>\n", "bases": "composable_mapping.sampler.interface.ISampler"}, {"fullname": "composable_mapping.ScalingAndSquaring.__init__", "modulename": "composable_mapping", "qualname": "ScalingAndSquaring.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">steps</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">7</span>,</span><span class=\"param\">\t<span class=\"n\">sampler</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">inverse</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">mask_extrapolated_regions_for_empty_volume_mask</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span>)</span>"}, {"fullname": "composable_mapping.ScalingAndSquaring.derivative", "modulename": "composable_mapping", "qualname": "ScalingAndSquaring.derivative", "kind": "function", "doc": "<p>Obtain sampler for sampling derivatives corresponding to the current sampler.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_dim:</strong>  Spatial dimension along which to compute the derivative.</li>\n<li><strong>limit_direction:</strong>  Direction in which to compute the derivative.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampler for sampling derivatives.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">limit_direction</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span><span class=\"p\">,</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ScalingAndSquaring.inverse", "modulename": "composable_mapping", "qualname": "ScalingAndSquaring.inverse", "kind": "function", "doc": "<p>Obtain sampler for sampling inverse values corresponding to the\ncurrent sampler, if available.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>coordinate_system:</strong>  Coordinate system of the mapping.</li>\n<li><strong>data_format:</strong>  Data format of the sampled volume.</li>\n<li><strong>arguments:</strong>  Additional arguments for the inverse.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampler for sampling inverse values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">coordinate_system</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>,</span><span class=\"param\">\t<span class=\"n\">data_format</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span>,</span><span class=\"param\">\t<span class=\"n\">arguments</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Mapping</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ScalingAndSquaring.sample_values", "modulename": "composable_mapping", "qualname": "ScalingAndSquaring.sample_values", "kind": "function", "doc": "<p>Sample values at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>volume:</strong>  Volume to sample over spatial dimensions\nwith shape (*batch_shape, *channels_shape, *spatial_shape)</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sampled values with shape (*batch_shape, *channels_shape, *target_shape).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.ScalingAndSquaring.sample_mask", "modulename": "composable_mapping", "qualname": "ScalingAndSquaring.sample_mask", "kind": "function", "doc": "<p>Sample mask at spatial locations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mask:</strong>  Mask to sample over spatial dimensions\nwith shape (*batch_shape, *(1,) * n_channel_dims, *spatial_shape).</li>\n<li><strong>coordinates:</strong>  Coordinates in voxel coordinates with shape\n(*batch_shape, n_spatial_dims, *target_shape).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.Start", "modulename": "composable_mapping", "qualname": "Start", "kind": "class", "doc": "<p>Reference point at the start of the dimension.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fov_convention:</strong>  Convention for defining the field of view, either \"full_voxels\"\nor \"voxel_centers\". If voxels are seens as cubes with the value at the\ncenter, the convention \"full voxels\" includes the full cubes in the field\nof view, while the convention \"voxel_centers\" includes only the centers.\nThe latter results in a field of view that is one voxel smaller in each\ndimension. Similar to the align_corners option in\ntorch.nn.functional.grid_sample</li>\n</ul>\n", "bases": "composable_mapping.coordinate_system.reformatting_reference.ReformattingReference"}, {"fullname": "composable_mapping.Start.__init__", "modulename": "composable_mapping", "qualname": "Start.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fov_convention</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;full_voxels&#39;</span></span>)</span>"}, {"fullname": "composable_mapping.Start.get_voxel_coordinate", "modulename": "composable_mapping", "qualname": "Start.get_voxel_coordinate", "kind": "function", "doc": "<p>Get a voxel coordinate corresponding to the reference position with\na given dimension size.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>size:</strong>  Size of the dimension</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Voxel coordinate corresponding to the reference position along the dimension.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">size</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.Center", "modulename": "composable_mapping", "qualname": "Center", "kind": "class", "doc": "<p>Reference point at the center of the dimension.</p>\n", "bases": "composable_mapping.coordinate_system.reformatting_reference.ReformattingReference"}, {"fullname": "composable_mapping.Center.get_voxel_coordinate", "modulename": "composable_mapping", "qualname": "Center.get_voxel_coordinate", "kind": "function", "doc": "<p>Get a voxel coordinate corresponding to the reference position with\na given dimension size.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>size:</strong>  Size of the dimension</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Voxel coordinate corresponding to the reference position along the dimension.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">size</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.End", "modulename": "composable_mapping", "qualname": "End", "kind": "class", "doc": "<p>Reference point at the end of the dimension.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>fov_convention:</strong>  Convention for defining the field of view, either \"full_voxels\"\nor \"voxel_centers\". If voxels are seens as cubes with the value at the\ncenter, the convention \"full voxels\" includes the full cubes in the field\nof view, while the convention \"voxel_centers\" includes only the centers.\nThe latter results in a field of view that is one voxel smaller in each\ndimension. Similar to the align_corners option in\ntorch.nn.functional.grid_sample</li>\n</ul>\n", "bases": "composable_mapping.coordinate_system.reformatting_reference.ReformattingReference"}, {"fullname": "composable_mapping.End.__init__", "modulename": "composable_mapping", "qualname": "End.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fov_convention</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;full_voxels&#39;</span></span>)</span>"}, {"fullname": "composable_mapping.End.get_voxel_coordinate", "modulename": "composable_mapping", "qualname": "End.get_voxel_coordinate", "kind": "function", "doc": "<p>Get a voxel coordinate corresponding to the reference position with\na given dimension size.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>size:</strong>  Size of the dimension</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Voxel coordinate corresponding to the reference position along the dimension.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">size</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine", "modulename": "composable_mapping", "qualname": "affine", "kind": "function", "doc": "<p>Create affine mapping from an affine transformation matrix.</p>\n\n<p>See: <code>Affine.from_matrix.</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_mapping</span><span class=\"o\">.</span><span class=\"n\">Affine</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.clear_default_sampler", "modulename": "composable_mapping", "qualname": "clear_default_sampler", "kind": "function", "doc": "<p>Clear default sampler</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.concatenate_mappings", "modulename": "composable_mapping", "qualname": "concatenate_mappings", "kind": "function", "doc": "<p>Concatenate mappings along a channel dimension.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mappings:</strong>  Mappings to concatenate.</li>\n<li><strong>channel_index:</strong>  Channel index along which to concatenate.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A mapping with the output being the outputs of the input mappings\n  concatenated along the channel dimension.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">mappings</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">ComposableMappingT</span>,</span><span class=\"param\">\t<span class=\"n\">channel_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"o\">~</span><span class=\"n\">ComposableMappingT</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.concatenate_mappable_tensors", "modulename": "composable_mapping", "qualname": "concatenate_mappable_tensors", "kind": "function", "doc": "<p>Concatenate mappable tensors along the channel dimension</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mappable_tensors:</strong>  Masked tensors to concatenate</li>\n<li><strong>channel_index:</strong>  Index of the channel dimension starting from the first\nchannel dimension over which to concatenate.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Concatenated masked tensor.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">mappable_tensors</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>,</span><span class=\"param\">\t<span class=\"n\">channel_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.default_sampler", "modulename": "composable_mapping", "qualname": "default_sampler", "kind": "class", "doc": "<p>Context manager for setting default sampler</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sampler:</strong>  Sampler to set as default.</li>\n</ul>\n", "bases": "contextlib.ContextDecorator"}, {"fullname": "composable_mapping.default_sampler.__init__", "modulename": "composable_mapping", "qualname": "default_sampler.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sampler</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span></span>)</span>"}, {"fullname": "composable_mapping.default_sampler.sampler", "modulename": "composable_mapping", "qualname": "default_sampler.sampler", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "composable_mapping.diagonal_affine", "modulename": "composable_mapping", "qualname": "diagonal_affine", "kind": "function", "doc": "<p>Create affine mapping from diagonal and translation.</p>\n\n<p>See: <code>Affine.from_diagonal_and_translation</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">diagonal</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">matrix_shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_mapping</span><span class=\"o\">.</span><span class=\"n\">Affine</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.estimate_spatial_jacobian_matrices", "modulename": "composable_mapping", "qualname": "estimate_spatial_jacobian_matrices", "kind": "function", "doc": "<p>Estimate spatial Jacobian matrices of a grid composable mapping.</p>\n\n<p>Estimation is done based on samples of the mapping at the grid defined by\nthe coordinate system of the mapping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mapping:</strong>  Grid composable mapping to estimate the Jacobian matrices for.</li>\n<li><strong>target:</strong>  Target locations at which to estimate the Jacobian matrices.</li>\n<li><strong>limit_direction:</strong>  Direction in which to compute the derivatives, e.g. average\nand LinearInterpolator corresponds to central finite differences when\nestimated at the grid points.</li>\n<li><strong>sampler:</strong>  Sampler to use for the derivative estimation, e.g. LinearInterpolator\ncorresponds to finite differences.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>MappableTensor with the estimated Jacobian matrices over spatial locations.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mapping</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">GridComposableMapping</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ICoordinateSystemContainer</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">limit_direction</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">LimitDirection</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">sampler</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.get_default_sampler", "modulename": "composable_mapping", "qualname": "get_default_sampler", "kind": "function", "doc": "<p>Get current default sampler</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.get_sampler", "modulename": "composable_mapping", "qualname": "get_sampler", "kind": "function", "doc": "<p>Get sampler, either from argument or default</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sampler</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.mappable", "modulename": "composable_mapping", "qualname": "mappable", "kind": "function", "doc": "<p>Create a mappable tensor from values and mask</p>\n\n<p>See: <code>MappableTensor.from_tensor</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.samplable_volume", "modulename": "composable_mapping", "qualname": "samplable_volume", "kind": "function", "doc": "<p>Create a samplable volume from a tensor.</p>\n\n<p>See: <code>SamplableVolume.from_tensor</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">coordinate_system</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">coordinate_system</span><span class=\"o\">.</span><span class=\"n\">CoordinateSystem</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">data_format</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">DataFormat</span> <span class=\"o\">=</span> <span class=\"n\">DataFormat</span><span class=\"p\">(</span><span class=\"n\">representation</span><span class=\"o\">=</span><span class=\"n\">coordinates</span><span class=\"p\">,</span> <span class=\"n\">coordinate_type</span><span class=\"o\">=</span><span class=\"n\">world</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">sampler</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">GridComposableMapping</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.set_default_sampler", "modulename": "composable_mapping", "qualname": "set_default_sampler", "kind": "function", "doc": "<p>Set default sampler</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>sampler:</strong>  Sampler to set as default.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">sampler</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">sampler</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ISampler</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.stack_mappings", "modulename": "composable_mapping", "qualname": "stack_mappings", "kind": "function", "doc": "<p>Stack mappings along a channel dimension.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mappings:</strong>  Mappings to stack.</li>\n<li><strong>channel_index:</strong>  Channel index along which to stack.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A mapping with the output being the outputs of the input mappings\n  stacked along the channel dimension.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">mappings</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">ComposableMappingT</span>,</span><span class=\"param\">\t<span class=\"n\">channel_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"o\">~</span><span class=\"n\">ComposableMappingT</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.stack_mappable_tensors", "modulename": "composable_mapping", "qualname": "stack_mappable_tensors", "kind": "function", "doc": "<p>Stack mappable tensors along the channel dimension.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>mappable_tensors:</strong>  Mappable tensors to concatenate</li>\n<li><strong>channel_index:</strong>  Index of the channel dimension over which to stack\nstarting from the first channel dimension over which to stack.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Stacked masked tensor.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">mappable_tensors</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>,</span><span class=\"param\">\t<span class=\"n\">channel_index</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.voxel_grid", "modulename": "composable_mapping", "qualname": "voxel_grid", "kind": "function", "doc": "<p>Create a voxel grid with optional mask.</p>\n\n<p>The voxel grid is not generated explicitly right away, but only when the\nvalues are generated.</p>\n\n<p>See: <code>MappableTensor.voxel_grid</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spatial_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">mask</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.visualize_as_deformed_grid", "modulename": "composable_mapping", "qualname": "visualize_as_deformed_grid", "kind": "function", "doc": "<p>Visualize a grid mapping as a grid</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mapping</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">GridComposableMapping</span>,</span><span class=\"param\">\t<span class=\"n\">arguments</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">visualization</span><span class=\"o\">.</span><span class=\"n\">GridVisualizationArguments</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.visualize_as_image", "modulename": "composable_mapping", "qualname": "visualize_as_image", "kind": "function", "doc": "<p>Visualize a grid mapping as an image</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mapping</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">GridComposableMapping</span>,</span><span class=\"param\">\t<span class=\"n\">arguments</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">visualization</span><span class=\"o\">.</span><span class=\"n\">ImageVisualizationArguments</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.visualize_grid", "modulename": "composable_mapping", "qualname": "visualize_grid", "kind": "function", "doc": "<p>Visualize coordinates as a grid</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>,</span><span class=\"param\">\t<span class=\"n\">arguments</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">visualization</span><span class=\"o\">.</span><span class=\"n\">GridVisualizationArguments</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"o\">.</span><span class=\"n\">Figure</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.visualize_image", "modulename": "composable_mapping", "qualname": "visualize_image", "kind": "function", "doc": "<p>Visualize coordinates as an image</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">volume</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">mappable_tensor</span><span class=\"o\">.</span><span class=\"n\">MappableTensor</span>,</span><span class=\"param\">\t<span class=\"n\">voxel_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">arguments</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">visualization</span><span class=\"o\">.</span><span class=\"n\">ImageVisualizationArguments</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">matplotlib</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"o\">.</span><span class=\"n\">Figure</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.visualize_to_as_deformed_grid", "modulename": "composable_mapping", "qualname": "visualize_to_as_deformed_grid", "kind": "function", "doc": "<p>Visualize a mapping to a target coordinate system as a grid</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mapping</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">ComposableMapping</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ICoordinateSystemContainer</span>,</span><span class=\"param\">\t<span class=\"n\">arguments</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">visualization</span><span class=\"o\">.</span><span class=\"n\">GridVisualizationArguments</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.visualize_to_as_image", "modulename": "composable_mapping", "qualname": "visualize_to_as_image", "kind": "function", "doc": "<p>Visualize a mapping to a target coordinate system as an image</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mapping</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">ComposableMapping</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">interface</span><span class=\"o\">.</span><span class=\"n\">ICoordinateSystemContainer</span>,</span><span class=\"param\">\t<span class=\"n\">arguments</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">visualization</span><span class=\"o\">.</span><span class=\"n\">ImageVisualizationArguments</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation", "modulename": "composable_mapping.affine_transformation", "kind": "module", "doc": "<p>Affine transformations on PyTorch tensors.</p>\n"}, {"fullname": "composable_mapping.affine_transformation.AffineTransformation", "modulename": "composable_mapping.affine_transformation", "qualname": "AffineTransformation", "kind": "class", "doc": "<p>Generic affine transformation</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>transformation_matrix:</strong>  Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape])</li>\n</ul>\n", "bases": "composable_mapping.affine_transformation.affine_transformation.BaseAffineTransformation, composable_mapping.tensor_like.BaseTensorLikeWrapper"}, {"fullname": "composable_mapping.affine_transformation.AffineTransformation.__init__", "modulename": "composable_mapping.affine_transformation", "qualname": "AffineTransformation.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">transformation_matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span>)</span>"}, {"fullname": "composable_mapping.affine_transformation.AffineTransformation.shape", "modulename": "composable_mapping.affine_transformation", "qualname": "AffineTransformation.shape", "kind": "variable", "doc": "<p>Shape of the transformation when represented as an affine\ntransformation matrix</p>\n\n<p>The spape is in form\n    ([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape])</p>\n", "annotation": ": Sequence[int]"}, {"fullname": "composable_mapping.affine_transformation.AffineTransformation.as_matrix", "modulename": "composable_mapping.affine_transformation", "qualname": "AffineTransformation.as_matrix", "kind": "function", "doc": "<p>Obtain the transformation as the corresponding affine transformation\nmatrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.AffineTransformation.as_host_matrix", "modulename": "composable_mapping.affine_transformation", "qualname": "AffineTransformation.as_host_matrix", "kind": "function", "doc": "<p>Obtain the transformation as the corresonding affine transformation\nmatrix on host (cpu), if available</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.AffineTransformation.invert", "modulename": "composable_mapping.affine_transformation", "qualname": "AffineTransformation.invert", "kind": "function", "doc": "<p>Invert the transformation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">AffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.AffineTransformation.clear_translation", "modulename": "composable_mapping.affine_transformation", "qualname": "AffineTransformation.clear_translation", "kind": "function", "doc": "<p>Clear translation from the transformation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">AffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineMatrixDefinition", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineMatrixDefinition", "kind": "class", "doc": "<p>Definition of a diagonal affine matrix</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>diagonal:</strong>  Tensor with shape ([*batch_shape, ]diagonal_length[, *spatial_shape]),\nif None, corresponds to all ones. Can also be given as a sequence of numbers\nor a single number.</li>\n<li><strong>translation:</strong>  Tensor with shape ([*batch_shape, ]n_output_dims[, *spatial_shape]),\nif None, corresponds to all zeros. Can also be given as a sequence of numbers\nor a single number.</li>\n<li><strong>matrix_shape:</strong>  Shape of the target affine transformation matrix\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape])</li>\n<li><strong>dtype:</strong>  Data type of the transformation matrix, needed only if no\ndiagonal or translation is given.</li>\n<li><strong>device:</strong>  Device of the transformation matrix, needed only if no\ndiagonal or translation is given.</li>\n</ul>\n", "bases": "composable_mapping.tensor_like.BaseTensorLikeWrapper"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineMatrixDefinition.__init__", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineMatrixDefinition.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">diagonal</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">matrix_shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineMatrixDefinition.cast", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineMatrixDefinition.cast", "kind": "function", "doc": "<p>Cast to given data type and device.</p>\n\n<p>We will not use method name \"to\" as it would create conflict with\ntorch.nn.Module.to method which does casting in-place.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dtype:</strong>  Data type to cast to.</li>\n<li><strong>device:</strong>  Device to cast to.</li>\n<li><strong>non_blocking:</strong>  Whether to perform the operation asynchronously (if\npossible).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>New tensor like object with the casted tensor(s).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">non_blocking</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineMatrixDefinition.dtype", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineMatrixDefinition.dtype", "kind": "variable", "doc": "<p>PyTorch data type</p>\n", "annotation": ": torch.dtype"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineMatrixDefinition.device", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineMatrixDefinition.device", "kind": "variable", "doc": "<p>PyTorch device</p>\n", "annotation": ": torch.device"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineMatrixDefinition.diagonal", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineMatrixDefinition.diagonal", "kind": "variable", "doc": "<p>Diagonal of the matrix</p>\n\n<p>Batch and spatial dimensions are not broadcasted to the final matrix shape.</p>\n", "annotation": ": Union[torch.Tensor, NoneType]"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineMatrixDefinition.translation", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineMatrixDefinition.translation", "kind": "variable", "doc": "<p>Translation of the matrix</p>\n\n<p>Batch and spatial dimensions are not broadcasted to the final matrix shape.</p>\n", "annotation": ": Union[torch.Tensor, NoneType]"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineMatrixDefinition.shape", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineMatrixDefinition.shape", "kind": "variable", "doc": "<p>Matrix shape</p>\n", "annotation": ": Sequence[int]"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineMatrixDefinition.as_matrix", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineMatrixDefinition.as_matrix", "kind": "function", "doc": "<p>Generate the diagonal affine matrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineMatrixDefinition.generate_diagonal", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineMatrixDefinition.generate_diagonal", "kind": "function", "doc": "<p>Generate the diagonal</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineMatrixDefinition.generate_translation", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineMatrixDefinition.generate_translation", "kind": "function", "doc": "<p>Generate the translation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineMatrixDefinition.clear_translation", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineMatrixDefinition.clear_translation", "kind": "function", "doc": "<p>Clear the translation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineTransformation", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineTransformation", "kind": "class", "doc": "<p>Affine transformation representable as a diagonal affine transformation matrix</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>diagonal:</strong>  Tensor with shape ([*batch_shape, ]diagonal_length[, *spatial_shape]),\nif None, corresponds to all ones. Can also be given as a sequence of numbers\nor a single number.</li>\n<li><strong>translation:</strong>  Tensor with shape ([*batch_shape, ]n_output_dims[, *spatial_shape]),\nif None, corresponds to all zeros. Can also be given as a sequence of numbers\nor a single number.</li>\n<li><strong>matrix_shape:</strong>  Shape of the target affine transformation matrix\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape])</li>\n<li><strong>dtype:</strong>  Data type of the transformation matrix, needed only if no\ndiagonal or translation is given.</li>\n<li><strong>device:</strong>  Device of the transformation matrix, needed only if no\ndiagonal or translation is given.</li>\n</ul>\n", "bases": "composable_mapping.tensor_like.BaseTensorLikeWrapper, composable_mapping.affine_transformation.affine_transformation.BaseDiagonalAffineTransformation"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineTransformation.__init__", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineTransformation.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">diagonal</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">matrix_shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineTransformation.from_definition", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineTransformation.from_definition", "kind": "function", "doc": "<p>Create diagonal affine transformation from definition</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">matrix_definition</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineTransformation.shape", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineTransformation.shape", "kind": "variable", "doc": "<p>Shape of the transformation when represented as an affine\ntransformation matrix</p>\n\n<p>The spape is in form\n    ([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape])</p>\n", "annotation": ": Sequence[int]"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineTransformation.as_matrix", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineTransformation.as_matrix", "kind": "function", "doc": "<p>Obtain the transformation as the corresponding affine transformation\nmatrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineTransformation.as_host_matrix", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineTransformation.as_host_matrix", "kind": "function", "doc": "<p>Obtain the transformation as the corresonding affine transformation\nmatrix on host (cpu), if available</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineTransformation.as_diagonal", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineTransformation.as_diagonal", "kind": "function", "doc": "<p>Return the diagonal and translation tensors</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineTransformation.as_host_diagonal", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineTransformation.as_host_diagonal", "kind": "function", "doc": "<p>Return the diagonal and translation tensors detached on cpu, if available</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineTransformation.invert", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineTransformation.invert", "kind": "function", "doc": "<p>Invert the transformation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineTransformation.is_zero", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineTransformation.is_zero", "kind": "function", "doc": "<p>Return whether the transformation corresponds to zero matrix</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>None if the check cannot be done on CPU, otherwise bool indicating\n  whether the transformation is zero matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.DiagonalAffineTransformation.clear_translation", "modulename": "composable_mapping.affine_transformation", "qualname": "DiagonalAffineTransformation.clear_translation", "kind": "function", "doc": "<p>Clear translation from the transformation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostAffineTransformation", "modulename": "composable_mapping.affine_transformation", "qualname": "HostAffineTransformation", "kind": "class", "doc": "<p>Affine transformation with the matrix stored on host (cpu) and the matrix\non target device created only when needed.</p>\n\n<p>Allows to do control flow decisions on host based on the transformation\nwithout having to do CPU-GPU synchronization.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>transformation_matrix_on_host:</strong>  Transformation matrix on cpu, tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</li>\n<li><strong>device:</strong>  Device to use for the transformation matrix produced by as_matrix method.</li>\n</ul>\n", "bases": "composable_mapping.affine_transformation.affine_transformation.AffineTransformation, composable_mapping.affine_transformation.affine_transformation.IHostAffineTransformation"}, {"fullname": "composable_mapping.affine_transformation.HostAffineTransformation.__init__", "modulename": "composable_mapping.affine_transformation", "qualname": "HostAffineTransformation.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">transformation_matrix_on_host</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "composable_mapping.affine_transformation.HostAffineTransformation.as_matrix", "modulename": "composable_mapping.affine_transformation", "qualname": "HostAffineTransformation.as_matrix", "kind": "function", "doc": "<p>Obtain the transformation as the corresponding affine transformation\nmatrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostAffineTransformation.as_host_matrix", "modulename": "composable_mapping.affine_transformation", "qualname": "HostAffineTransformation.as_host_matrix", "kind": "function", "doc": "<p>Obtain the transformation as the corresonding affine transformation\nmatrix on host (cpu), if available</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostAffineTransformation.detach", "modulename": "composable_mapping.affine_transformation", "qualname": "HostAffineTransformation.detach", "kind": "function", "doc": "<p>Detach the wrapped tensors from computational graph.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">HostAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostAffineTransformation.device", "modulename": "composable_mapping.affine_transformation", "qualname": "HostAffineTransformation.device", "kind": "variable", "doc": "<p>PyTorch device.</p>\n", "annotation": ": torch.device"}, {"fullname": "composable_mapping.affine_transformation.HostAffineTransformation.cast", "modulename": "composable_mapping.affine_transformation", "qualname": "HostAffineTransformation.cast", "kind": "function", "doc": "<p>Cast to given data type and device.</p>\n\n<p>We will not use method name \"to\" as it would create conflict with\ntorch.nn.Module.to method which does casting in-place.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dtype:</strong>  Data type to cast to.</li>\n<li><strong>device:</strong>  Device to cast to.</li>\n<li><strong>non_blocking:</strong>  Whether to perform the operation asynchronously (if\npossible).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>New tensor like object with the casted tensor(s).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">non_blocking</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">HostAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostAffineTransformation.invert", "modulename": "composable_mapping.affine_transformation", "qualname": "HostAffineTransformation.invert", "kind": "function", "doc": "<p>Invert the transformation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">HostAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostAffineTransformation.clear_translation", "modulename": "composable_mapping.affine_transformation", "qualname": "HostAffineTransformation.clear_translation", "kind": "function", "doc": "<p>Clear translation from the transformation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">HostAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation", "kind": "class", "doc": "<p>Affine transformation representable as a diagonal affine transformation matrix\nwith the matrix stored on host (cpu) and the matrix on target device created\nonly when needed.</p>\n\n<p>Allows to do control flow decisions on host based on the transformation\nwithout having to do CPU-GPU synchronization.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>diagonal:</strong>  Tensor with shape ([*batch_shape, ]diagonal_length[, *spatial_shape]),\nif None, corresponds to all ones. Can also be given as a sequence of numbers\nor a single number.</li>\n<li><strong>translation:</strong>  Tensor with shape ([*batch_shape, ]n_output_dims[, *spatial_shape]),\nif None, corresponds to all zeros. Can also be given as a sequence of numbers\nor a single number.</li>\n<li><strong>matrix_shape:</strong>  Shape of the target affine transformation matrix\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape])</li>\n<li><strong>dtype:</strong>  Data type of the transformation matrix, needed only if no\ndiagonal or translation is given.</li>\n<li><strong>device:</strong>  Device of the transformation matrix generated by as_matrix and as_diagonal\nmethods.</li>\n</ul>\n", "bases": "composable_mapping.affine_transformation.affine_transformation.DiagonalAffineTransformation, composable_mapping.affine_transformation.affine_transformation.IHostAffineTransformation"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.__init__", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">diagonal</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">matrix_shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.from_definition", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.from_definition", "kind": "function", "doc": "<p>Create diagonal affine transformation from definition</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">matrix_definition</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">HostDiagonalAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.as_matrix", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.as_matrix", "kind": "function", "doc": "<p>Obtain the transformation as the corresponding affine transformation\nmatrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.as_host_matrix", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.as_host_matrix", "kind": "function", "doc": "<p>Obtain the transformation as the corresonding affine transformation\nmatrix on host (cpu), if available</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.as_diagonal", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.as_diagonal", "kind": "function", "doc": "<p>Return the diagonal and translation tensors</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.as_host_diagonal", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.as_host_diagonal", "kind": "function", "doc": "<p>Return the diagonal and translation tensors detached on cpu, if available</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.detach", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.detach", "kind": "function", "doc": "<p>Detach the wrapped tensors from computational graph.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">HostDiagonalAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.device", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.device", "kind": "variable", "doc": "<p>PyTorch device.</p>\n", "annotation": ": torch.device"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.cast", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.cast", "kind": "function", "doc": "<p>Cast to given data type and device.</p>\n\n<p>We will not use method name \"to\" as it would create conflict with\ntorch.nn.Module.to method which does casting in-place.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dtype:</strong>  Data type to cast to.</li>\n<li><strong>device:</strong>  Device to cast to.</li>\n<li><strong>non_blocking:</strong>  Whether to perform the operation asynchronously (if\npossible).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>New tensor like object with the casted tensor(s).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">non_blocking</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">HostDiagonalAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.invert", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.invert", "kind": "function", "doc": "<p>Invert the transformation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">HostDiagonalAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.is_identity", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.is_identity", "kind": "function", "doc": "<p>Return whether the transformation corresponds to identity matrix</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>None if the check cannot be done on CPU, otherwise bool indicating\n  whether the transformation is identity matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.is_zero", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.is_zero", "kind": "function", "doc": "<p>Return whether the transformation corresponds to zero matrix</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>None if the check cannot be done on CPU, otherwise bool indicating\n  whether the transformation is zero matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.HostDiagonalAffineTransformation.clear_translation", "modulename": "composable_mapping.affine_transformation", "qualname": "HostDiagonalAffineTransformation.clear_translation", "kind": "function", "doc": "<p>Clear translation from the transformation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">HostDiagonalAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation", "kind": "class", "doc": "<p>Affine transformation</p>\n", "bases": "composable_mapping.tensor_like.ITensorLike"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.invert", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.invert", "kind": "function", "doc": "<p>Invert the transformation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.as_matrix", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.as_matrix", "kind": "function", "doc": "<p>Obtain the transformation as the corresponding affine transformation\nmatrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.as_host_matrix", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.as_host_matrix", "kind": "function", "doc": "<p>Obtain the transformation as the corresonding affine transformation\nmatrix on host (cpu), if available</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.as_diagonal", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.as_diagonal", "kind": "function", "doc": "<p>Obtain the transformation as corresponding diagonal affine\ntransformation matrix, if available</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.as_host_diagonal", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.as_host_diagonal", "kind": "function", "doc": "<p>Obtain the mapping as corresponding diagonal affine transformation\nmatrix on host (cpu), if available</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.get_output_shape", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.get_output_shape", "kind": "function", "doc": "<p>Shape of the output tensor given the input shape</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input_shape:</strong>  Shape of the input tensor in form\n([*batch_shape, *channels_shape[:-1], ]n_input_dims[, *spatial_shape])</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions in the input tensor</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Shape of the output tensor in form\n      ([*batch_shape, *channels_shape[:-1], ]n_output_dims[, *spatial_shape])</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li>RuntimeError if the transformation is not compatible with the input shape</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">input_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.is_zero", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.is_zero", "kind": "function", "doc": "<p>Return whether the transformation corresponds to zero matrix</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>None if the check cannot be done on CPU, otherwise bool indicating\n  whether the transformation is zero matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.is_identity", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.is_identity", "kind": "function", "doc": "<p>Return whether the transformation corresponds to identity matrix</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>None if the check cannot be done on CPU, otherwise bool indicating\n  whether the transformation is identity matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.shape", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.shape", "kind": "variable", "doc": "<p>Shape of the transformation when represented as an affine\ntransformation matrix</p>\n\n<p>The spape is in form\n    ([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape])</p>\n", "annotation": ": Sequence[int]"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.batch_shape", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.batch_shape", "kind": "variable", "doc": "<p>Shape of the batch dimensions</p>\n", "annotation": ": Tuple[int, ...]"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.channels_shape", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.channels_shape", "kind": "variable", "doc": "<p>Shape of the channel dimensions</p>\n", "annotation": ": Tuple[int, ...]"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.spatial_shape", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.spatial_shape", "kind": "variable", "doc": "<p>Shape of the spatial dimensions</p>\n", "annotation": ": Tuple[int, ...]"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.is_composable", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.is_composable", "kind": "function", "doc": "<p>Is the transformation composable with the other transformation</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>affine_transformation:</strong>  Transformation to compose with</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Whether the transformation is composable with the other transformation</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">affine_transformation</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IAffineTransformation</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.is_addable", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.is_addable", "kind": "function", "doc": "<p>Is the transformation addable with the other transformation</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>affine_transformation:</strong>  Transformation to add with</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Whether the transformation is addable with the other transformation</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">affine_transformation</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IAffineTransformation</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.broadcast_to_n_output_channels", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.broadcast_to_n_output_channels", "kind": "function", "doc": "<p>Modify the transformation to output n_output_channels channels such that the output\nwould equal broadcasting the original output to have n_output_channels channels.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n_output_channels:</strong>  Number of output channels</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Affine transformation with n_output_channels output channels</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">n_output_channels</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IAffineTransformation.clear_translation", "modulename": "composable_mapping.affine_transformation", "qualname": "IAffineTransformation.clear_translation", "kind": "function", "doc": "<p>Clear translation from the transformation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IdentityAffineTransformation", "modulename": "composable_mapping.affine_transformation", "qualname": "IdentityAffineTransformation", "kind": "class", "doc": "<p>Identity affine transformation</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n_dims:</strong>  Number of spatial dimensions</li>\n<li><strong>dtype:</strong>  Data type of the transformation matrix</li>\n<li><strong>device:</strong>  Device of the transformation matrix</li>\n</ul>\n", "bases": "composable_mapping.affine_transformation.affine_transformation.HostDiagonalAffineTransformation"}, {"fullname": "composable_mapping.affine_transformation.IdentityAffineTransformation.__init__", "modulename": "composable_mapping.affine_transformation", "qualname": "IdentityAffineTransformation.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "composable_mapping.affine_transformation.IHostAffineTransformation", "modulename": "composable_mapping.affine_transformation", "qualname": "IHostAffineTransformation", "kind": "class", "doc": "<p>Affine transformation for which the matrix is stored on host (cpu) and\nthe matrix on target device is created only when needed.</p>\n\n<p>Allows to do control flow decisions on host based on the transformation\nwithout having to do CPU-GPU synchronization.</p>\n", "bases": "composable_mapping.affine_transformation.affine_transformation.IAffineTransformation"}, {"fullname": "composable_mapping.affine_transformation.IHostAffineTransformation.invert", "modulename": "composable_mapping.affine_transformation", "qualname": "IHostAffineTransformation.invert", "kind": "function", "doc": "<p>Invert the transformation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IHostAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IHostAffineTransformation.as_host_matrix", "modulename": "composable_mapping.affine_transformation", "qualname": "IHostAffineTransformation.as_host_matrix", "kind": "function", "doc": "<p>Obtain the transformation as the corresonding affine transformation\nmatrix on host (cpu)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.IHostAffineTransformation.clear_translation", "modulename": "composable_mapping.affine_transformation", "qualname": "IHostAffineTransformation.clear_translation", "kind": "function", "doc": "<p>Clear translation from the transformation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">IHostAffineTransformation</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "kind": "module", "doc": "<p>Core matrix operations for diagonal affine transformations.</p>\n"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.DiagonalAffineMatrixDefinition", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "DiagonalAffineMatrixDefinition", "kind": "class", "doc": "<p>Definition of a diagonal affine matrix</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>diagonal:</strong>  Tensor with shape ([*batch_shape, ]diagonal_length[, *spatial_shape]),\nif None, corresponds to all ones. Can also be given as a sequence of numbers\nor a single number.</li>\n<li><strong>translation:</strong>  Tensor with shape ([*batch_shape, ]n_output_dims[, *spatial_shape]),\nif None, corresponds to all zeros. Can also be given as a sequence of numbers\nor a single number.</li>\n<li><strong>matrix_shape:</strong>  Shape of the target affine transformation matrix\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape])</li>\n<li><strong>dtype:</strong>  Data type of the transformation matrix, needed only if no\ndiagonal or translation is given.</li>\n<li><strong>device:</strong>  Device of the transformation matrix, needed only if no\ndiagonal or translation is given.</li>\n</ul>\n", "bases": "composable_mapping.tensor_like.BaseTensorLikeWrapper"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.DiagonalAffineMatrixDefinition.__init__", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "DiagonalAffineMatrixDefinition.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">diagonal</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">translation</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">matrix_shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.DiagonalAffineMatrixDefinition.cast", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "DiagonalAffineMatrixDefinition.cast", "kind": "function", "doc": "<p>Cast to given data type and device.</p>\n\n<p>We will not use method name \"to\" as it would create conflict with\ntorch.nn.Module.to method which does casting in-place.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dtype:</strong>  Data type to cast to.</li>\n<li><strong>device:</strong>  Device to cast to.</li>\n<li><strong>non_blocking:</strong>  Whether to perform the operation asynchronously (if\npossible).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>New tensor like object with the casted tensor(s).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">device</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">device</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">non_blocking</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.DiagonalAffineMatrixDefinition.dtype", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "DiagonalAffineMatrixDefinition.dtype", "kind": "variable", "doc": "<p>PyTorch data type</p>\n", "annotation": ": torch.dtype"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.DiagonalAffineMatrixDefinition.device", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "DiagonalAffineMatrixDefinition.device", "kind": "variable", "doc": "<p>PyTorch device</p>\n", "annotation": ": torch.device"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.DiagonalAffineMatrixDefinition.diagonal", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "DiagonalAffineMatrixDefinition.diagonal", "kind": "variable", "doc": "<p>Diagonal of the matrix</p>\n\n<p>Batch and spatial dimensions are not broadcasted to the final matrix shape.</p>\n", "annotation": ": Union[torch.Tensor, NoneType]"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.DiagonalAffineMatrixDefinition.translation", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "DiagonalAffineMatrixDefinition.translation", "kind": "variable", "doc": "<p>Translation of the matrix</p>\n\n<p>Batch and spatial dimensions are not broadcasted to the final matrix shape.</p>\n", "annotation": ": Union[torch.Tensor, NoneType]"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.DiagonalAffineMatrixDefinition.shape", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "DiagonalAffineMatrixDefinition.shape", "kind": "variable", "doc": "<p>Matrix shape</p>\n", "annotation": ": Sequence[int]"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.DiagonalAffineMatrixDefinition.as_matrix", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "DiagonalAffineMatrixDefinition.as_matrix", "kind": "function", "doc": "<p>Generate the diagonal affine matrix</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.DiagonalAffineMatrixDefinition.generate_diagonal", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "DiagonalAffineMatrixDefinition.generate_diagonal", "kind": "function", "doc": "<p>Generate the diagonal</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.DiagonalAffineMatrixDefinition.generate_translation", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "DiagonalAffineMatrixDefinition.generate_translation", "kind": "function", "doc": "<p>Generate the translation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.DiagonalAffineMatrixDefinition.clear_translation", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "DiagonalAffineMatrixDefinition.clear_translation", "kind": "function", "doc": "<p>Clear the translation</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.transform_values_with_diagonal_affine_matrix", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "transform_values_with_diagonal_affine_matrix", "kind": "function", "doc": "<p>Transform values with a diagonal affine matrix</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix_definition:</strong>  Definition of the diagonal affine matrix.</li>\n<li><strong>values:</strong>  Values to transform.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions in the values tensor.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Values transformed with the diagonal affine matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">matrix_definition</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.invert_diagonal_affine_matrix", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "invert_diagonal_affine_matrix", "kind": "function", "doc": "<p>Invert a diagonal affine matrix</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix_definition:</strong>  Definition of the diagonal affine matrix.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Definition of the inverted diagonal affine matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">matrix_definition</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.negate_diagonal_affine_matrix", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "negate_diagonal_affine_matrix", "kind": "function", "doc": "<p>Negate diagonal affine matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix_definition:</strong>  Definition of the diagonal affine matrix.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Definition of the negated diagonal affine matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">matrix_definition</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.is_identity_diagonal_affine_matrix", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "is_identity_diagonal_affine_matrix", "kind": "function", "doc": "<p>Is the diagonal matrix an identity matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix_definition:</strong>  Definition of the diagonal affine matrix.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Whether the diagonal matrix is an identity matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">matrix_definition</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.is_zero_diagonal_affine_matrix", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "is_zero_diagonal_affine_matrix", "kind": "function", "doc": "<p>Is the diagonal matrix a zero matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix_definition:</strong>  Definition of the diagonal affine matrix.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Whether the diagonal matrix is a zero matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">matrix_definition</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.compose_diagonal_affine_matrices", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "compose_diagonal_affine_matrices", "kind": "function", "doc": "<p>Compose two diagonal affine matrices.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix_definition_1:</strong>  Definition of the first diagonal affine matrix.</li>\n<li><strong>matrix_definition_2:</strong>  Definition of the second diagonal affine matrix.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Definition of the composed diagonal affine matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">matrix_definition_1</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>,</span><span class=\"param\">\t<span class=\"n\">matrix_definition_2</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.diagonal_matrix.add_diagonal_affine_matrices", "modulename": "composable_mapping.affine_transformation.diagonal_matrix", "qualname": "add_diagonal_affine_matrices", "kind": "function", "doc": "<p>Add two diagonal affine matrices.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix_definition_1:</strong>  Definition of the first diagonal affine matrix.</li>\n<li><strong>matrix_definition_2:</strong>  Definition of the second diagonal affine matrix.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Definition of the sum of the two diagonal affine matrices.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">matrix_definition_1</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>,</span><span class=\"param\">\t<span class=\"n\">matrix_definition_2</span><span class=\"p\">:</span> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span></span><span class=\"return-annotation\">) -> <span class=\"n\">composable_mapping</span><span class=\"o\">.</span><span class=\"n\">affine_transformation</span><span class=\"o\">.</span><span class=\"n\">diagonal_matrix</span><span class=\"o\">.</span><span class=\"n\">DiagonalAffineMatrixDefinition</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix", "modulename": "composable_mapping.affine_transformation.matrix", "kind": "module", "doc": "<p>Core matrix operations for generic affine transformations.</p>\n"}, {"fullname": "composable_mapping.affine_transformation.matrix.IDENTITY_MATRIX_TOLERANCE", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "IDENTITY_MATRIX_TOLERANCE", "kind": "variable", "doc": "<p></p>\n", "default_value": "1e-05"}, {"fullname": "composable_mapping.affine_transformation.matrix.ZERO_MATRIX_TOLERANCE", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "ZERO_MATRIX_TOLERANCE", "kind": "variable", "doc": "<p></p>\n", "default_value": "1e-05"}, {"fullname": "composable_mapping.affine_transformation.matrix.compose_affine_matrices", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "compose_affine_matrices", "kind": "function", "doc": "<p>Compose two transformation matrices</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>transformations:</strong>  Tensors with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape])</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Composed transformation matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">transformations</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix.embed_matrix", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "embed_matrix", "kind": "function", "doc": "<p>Embed transformation into larger dimensional space.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix:</strong>  Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape])</li>\n<li><strong>target_shape:</strong>  Target matrix shape in form</li>\n<li>(n_target_output_dims + 1, n_target_input_dims + 1).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Embedded matrix with shape\n  ([*batch_shape, ]n_target_output_dims + 1, n_target_input_dims + 1[, *spatial_shape])</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">target_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix.convert_to_homogenous_coordinates", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "convert_to_homogenous_coordinates", "kind": "function", "doc": "<p>Converts the coordinates to homogenous coordinates.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>coordinates:</strong>  Tensor with shape\n(dim_1, ..., dim_{dim}, ..., dim_{n_dims}).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tensor with shape\n  (dim_1, ..., dim_{dim + 1}, ..., dim_{n_dims}).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">coordinates</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix.generate_translation_matrix", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "generate_translation_matrix", "kind": "function", "doc": "<p>Generator affine translation matrix with given translations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>translations:</strong>  Tensor with shape\n([*batch_shape, ]n_dims[, *spatial_shape]).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Translation matrix with shape (batch_size, n_dims + 1, n_dims + 1, ...).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">translations</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix.generate_scale_matrix", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "generate_scale_matrix", "kind": "function", "doc": "<p>Generator scale matrix from given scales.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>scales:</strong>  Tensor with shape ([*batch_shape, ]n_dims[, *spatial_shape]).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Scale matrix with shape ([*batch_shape, ]n_dims, n_dims[, *spatial_shape]).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">scales</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix.invert_matrix", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "invert_matrix", "kind": "function", "doc": "<p>Invert an affine matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix:</strong>  Tensor with shape\n([*batch_shape, ]n_dims + 1, n_dims + 1[, *spatial_shape]).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Inverted matrix with shape\n  ([*batch_shape, ]n_dims + 1, n_dims + 1[, *spatial_shape]).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix.add_affine_matrices", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "add_affine_matrices", "kind": "function", "doc": "<p>Add two affine matrices or batches of matrices</p>\n\n<p>The last row of the matrices is not included in the addition\nand is copied from the first matrix, as it should always be\n[0, ..., 0, 1] for affine transformations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix_1:</strong>  Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</li>\n<li><strong>matrix_2:</strong>  Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Sum matrix with shape\n  ([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">matrix_1</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">matrix_2</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix.substract_affine_matrices", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "substract_affine_matrices", "kind": "function", "doc": "<p>Subtract two affine matrices or batches of matrices</p>\n\n<p>The last row of the matrices is not included in the subtraction\nand is copied from the first matrix, as it should always be\n[0, ..., 0, 1] for affine transformations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix_1:</strong>  Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</li>\n<li><strong>matrix_2:</strong>  Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Difference matrix with shape\n  ([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">matrix_1</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">matrix_2</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix.negate_affine_matrix", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "negate_affine_matrix", "kind": "function", "doc": "<p>Negate an affine matrix or a batch of matrices</p>\n\n<p>The last row of the matrix is not negated as it should always be\n[0, ..., 0, 1] for affine transformations.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix:</strong>  Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Negated matrix with shape\n  ([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix.is_zero_matrix", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "is_zero_matrix", "kind": "function", "doc": "<p>Is matrix a zero matrix</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix:</strong>  Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Whether the matrix is a zero matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix.is_identity_matrix", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "is_identity_matrix", "kind": "function", "doc": "<p>Is a matrix an identity matrix</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix:</strong>  Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Whether the matrix is an identity matrix.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix.transform_values_with_affine_matrix", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "transform_values_with_affine_matrix", "kind": "function", "doc": "<p>Transform values with affine matrix.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>transformation_matrix:</strong>  Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</li>\n<li><strong>values:</strong>  Tensor with shape\n([*batch_shape, *channels_shape[:-1], ]n_input_dims[, *spatial_shape]).</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions in the values tensor.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Transformed values with shape\n  ([*batch_shape, *channels_shape[:-1], ]n_output_dims[, *spatial_shape]).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">transformation_matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.affine_transformation.matrix.clear_translation_from_affine_matrix", "modulename": "composable_mapping.affine_transformation.matrix", "qualname": "clear_translation_from_affine_matrix", "kind": "function", "doc": "<p>Clear translation from affine matrix</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>matrix:</strong>  Tensor with shape\n([*batch_shape, ]n_output_dims + 1, n_input_dims + 1[, *spatial_shape]).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Affine matrix with cleared translation.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">matrix</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util", "modulename": "composable_mapping.util", "kind": "module", "doc": "<p>Utility functions for common tasks.</p>\n"}, {"fullname": "composable_mapping.util.get_batch_dims", "modulename": "composable_mapping.util", "qualname": "get_batch_dims", "kind": "function", "doc": "<p>Obtain indices for batch dimensions.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n_total_dims:</strong>  Number of total dimensions.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Indices for batch dimensions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n_total_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.get_spatial_dims", "modulename": "composable_mapping.util", "qualname": "get_spatial_dims", "kind": "function", "doc": "<p>Obtain indices for spatial dimensions.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n_total_dims:</strong>  Number of total dimensions.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Indices for spatial dimensions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n_total_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.get_channel_dims", "modulename": "composable_mapping.util", "qualname": "get_channel_dims", "kind": "function", "doc": "<p>Obtain indices for channel dimensions.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n_total_dims:</strong>  Number of total dimensions.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Indices for channel dimensions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n_total_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.get_batch_shape", "modulename": "composable_mapping.util", "qualname": "get_batch_shape", "kind": "function", "doc": "<p>Obtain shape of the batch dimensions.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape:</strong>  Shape of the tensor.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Shape of the batch dimensions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.get_spatial_shape", "modulename": "composable_mapping.util", "qualname": "get_spatial_shape", "kind": "function", "doc": "<p>Obtain shape of the spatial dimensions.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape:</strong>  Shape of the tensor.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Shape of the spatial dimensions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.get_channels_shape", "modulename": "composable_mapping.util", "qualname": "get_channels_shape", "kind": "function", "doc": "<p>Obtain shape of the channel dimensions.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape:</strong>  Shape of the tensor.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Shape of the channel dimensions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.has_spatial_dims", "modulename": "composable_mapping.util", "qualname": "has_spatial_dims", "kind": "function", "doc": "<p>Has the shape spatial dimensions.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape:</strong>  Shape of the tensor.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Whether the shape has spatial dimensions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.reduce_channels_shape_to_ones", "modulename": "composable_mapping.util", "qualname": "reduce_channels_shape_to_ones", "kind": "function", "doc": "<p>Modify channel shape to ones.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<p>E.g. (3, 5, 4, 4) with n_channel_dims = 2 returns\n(3, 1, 1, 4).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape:</strong>  Shape of the tensor.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Shape with channel dimensions reduced to ones.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.get_n_channel_dims", "modulename": "composable_mapping.util", "qualname": "get_n_channel_dims", "kind": "function", "doc": "<p>Obtain number of channel dimensions based on number of spatial\ndimensions, if possible.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>n_total_dims:</strong>  Number of total dimensions.</li>\n<li><strong>n_spatial_dims:</strong>  Number of spatial dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Number of channel dimensions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n_total_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">n_spatial_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.move_channels_first", "modulename": "composable_mapping.util", "qualname": "move_channels_first", "kind": "function", "doc": "<p>Move channel dimensions back from being the last dimensions.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tensor:</strong>  Tensor with shape\n(*batch_shape, *spatial_shape, *channels_shape).</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tensor with shape\n  (*batch_shape, *channels_shape, *spatial_shape)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tensor</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.move_channels_last", "modulename": "composable_mapping.util", "qualname": "move_channels_last", "kind": "function", "doc": "<p>Move channel dimensions last</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tensor:</strong>  Tensor with shape\n(*batch_shape, *channels_shape, *spatial_shape)</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tensor with shape\n  (*batch_shape, *spatial_shape, *channels_shape)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tensor</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>, </span><span class=\"param\"><span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.broadcast_shapes_in_parts_splitted", "modulename": "composable_mapping.util", "qualname": "broadcast_shapes_in_parts_splitted", "kind": "function", "doc": "<p>Broadcast batch dimension, channel dimensions and spatial dimensions separately.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shapes:</strong>  Shapes to broadcast.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dims for each shape, if integer is\ngiven, same number will be used for all shapes.</li>\n<li><strong>broadcast_batch:</strong>  Whether to broadcast batch dimension.</li>\n<li><strong>broadcast_channels:</strong>  Whether to broadcast channel dimensions.</li>\n<li><strong>broadcast_spatial:</strong>  Whether to broadcast spatial dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple of broadcasted batch shape, broadcasted channel shape and\n  broadcasted spatial shape. If the part of the shape is not broadcasted,\n  None is returned.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">shapes</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_batch</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_channels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_spatial</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.broadcast_optional_shapes_in_parts_splitted", "modulename": "composable_mapping.util", "qualname": "broadcast_optional_shapes_in_parts_splitted", "kind": "function", "doc": "<p>Broadcast batch dimension, channel dimensions and spatial dimensions\nseparately for optional shapes.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shapes:</strong>  Optional shapes to broadcast. If None, the value is ignored.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dims for each shape, if integer is\ngiven, same number will be used for all shapes.</li>\n<li><strong>broadcast_batch:</strong>  Whether to broadcast batch dimension.</li>\n<li><strong>broadcast_channels:</strong>  Whether to broadcast channel dimensions.</li>\n<li><strong>broadcast_spatial:</strong>  Whether to broadcast spatial dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple of broadcasted batch shape, broadcasted channel shape and\n  broadcasted spatial shape. If the part of the shape is not broadcasted,\n  None is returned.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">shapes</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_batch</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_channels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_spatial</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.broadcast_shapes_in_parts", "modulename": "composable_mapping.util", "qualname": "broadcast_shapes_in_parts", "kind": "function", "doc": "<p>Broadcast batch dimension, channel dimensions and spatial dimensions\nseparately while returning the broadcasted full shapes.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shapes:</strong>  Shapes to broadcast.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dims for each shape, if integer is\ngiven, same number will be used for all shapes.</li>\n<li><strong>broadcast_batch:</strong>  Whether to broadcast batch dimension.</li>\n<li><strong>broadcast_channels:</strong>  Whether to broadcast channel dimensions.</li>\n<li><strong>broadcast_spatial:</strong>  Whether to broadcast spatial dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Broadcasted shapes.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">shapes</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_batch</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_channels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_spatial</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.broadcast_shapes_in_parts_to_single_shape", "modulename": "composable_mapping.util", "qualname": "broadcast_shapes_in_parts_to_single_shape", "kind": "function", "doc": "<p>Broadcasts batch dimension, channel dimensions and spatial dimensions\nseparately while returning a single broadcasted shape.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shapes:</strong>  Shapes to broadcast.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dims for each shape, if integer is\ngiven, same number will be used for all shapes.</li>\n<li><strong>broadcast_batch:</strong>  Whether to broadcast batch dimension.</li>\n<li><strong>broadcast_channels:</strong>  Whether to broadcast channel dimensions.</li>\n<li><strong>broadcast_spatial:</strong>  Whether to broadcast spatial dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Broadcasted shape.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>RuntimeError:</strong>  If the shapes do not broadcast to the same shape.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">shapes</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_batch</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_channels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_spatial</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.broadcast_optional_shapes_in_parts_to_single_shape", "modulename": "composable_mapping.util", "qualname": "broadcast_optional_shapes_in_parts_to_single_shape", "kind": "function", "doc": "<p>Broadcasts batch dimension, channel dimensions and spatial dimensions of\noptional shapes separately while returning a single broadcasted shape.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shapes:</strong>  Optional shapes to broadcast.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dims for each shape, if integer is\ngiven, same number will be used for all shapes.</li>\n<li><strong>broadcast_batch:</strong>  Whether to broadcast batch dimension.</li>\n<li><strong>broadcast_channels:</strong>  Whether to broadcast channel dimensions.</li>\n<li><strong>broadcast_spatial:</strong>  Whether to broadcast spatial dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Broadcasted shape.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>RuntimeError:</strong>  If the shapes do not broadcast to the same shape or if\nno shapes are provided.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">shapes</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_batch</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_channels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_spatial</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.broadcast_to_in_parts", "modulename": "composable_mapping.util", "qualname": "broadcast_to_in_parts", "kind": "function", "doc": "<p>Broadcasts tensor to given batch, channel and spatial shapes separately.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tensor:</strong>  Tensor to broadcast.</li>\n<li><strong>batch_shape:</strong>  Shape of the batch dimensions to broadcast to.</li>\n<li><strong>channels_shape:</strong>  Shape of the channel dimensions to broadcast to.</li>\n<li><strong>spatial_shape:</strong>  Shape of the spatial dimensions to broadcast to.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Broadcasted tensor.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tensor</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">batch_shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">channels_shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">spatial_shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.broadcast_tensors_in_parts", "modulename": "composable_mapping.util", "qualname": "broadcast_tensors_in_parts", "kind": "function", "doc": "<p>Broadcast multiple tensors separately for batch, channel and spatial\ndimensions.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tensors:</strong>  Tensors to broadcast.</li>\n<li><strong>broadcast_batch:</strong>  Whether to broadcast batch dimension.</li>\n<li><strong>broadcast_channels:</strong>  Whether to broadcast channel dimensions.</li>\n<li><strong>broadcast_spatial:</strong>  Whether to broadcast spatial dimensions.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dims for each tensor, if integer is\ngiven, same number will be used for all tensors.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Broadcasted tensors.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">tensors</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_batch</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_channels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_spatial</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.broadcast_optional_tensors_in_parts", "modulename": "composable_mapping.util", "qualname": "broadcast_optional_tensors_in_parts", "kind": "function", "doc": "<p>Broadcast multiple optional tensors separately for batch, channel and\nspatial dimensions.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tensors:</strong>  Optional tensors to broadcast.</li>\n<li><strong>broadcast_batch:</strong>  Whether to broadcast batch dimension.</li>\n<li><strong>broadcast_channels:</strong>  Whether to broadcast channel dimensions.</li>\n<li><strong>broadcast_spatial:</strong>  Whether to broadcast spatial dimensions.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dims for each tensor, if integer is\ngiven, same number will be used for all tensors.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Broadcasted tensors with the same None positions as the input tensors.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">tensors</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_batch</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_channels</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">broadcast_spatial</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"o\">...</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.split_shape", "modulename": "composable_mapping.util", "qualname": "split_shape", "kind": "function", "doc": "<p>Splits shape into batch, channel and spatial shapes.</p>\n\n<p>See <code>composable_mapping</code> for special handling of shapes in the codebase.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape:</strong>  Shape of the tensor.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple of batch shape, channel shape and spatial shape.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.combine_optional_masks", "modulename": "composable_mapping.util", "qualname": "combine_optional_masks", "kind": "function", "doc": "<p>Combine optional masks.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>masks:</strong>  Masks to combine.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dims for each mask, if integer is\ngiven, same number will be used for all masks.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Combined mask.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">masks</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.are_broadcastable", "modulename": "composable_mapping.util", "qualname": "are_broadcastable", "kind": "function", "doc": "<p>Check if two shapes are broadcastable.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>shape_1:</strong>  First shape.</li>\n<li><strong>shape_2:</strong>  Second shape.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Whether the shapes are broadcastable.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape_1</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">shape_2</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.is_broadcastable_to", "modulename": "composable_mapping.util", "qualname": "is_broadcastable_to", "kind": "function", "doc": "<p>Check if source shape is broadcastable to target shape.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>source_shape:</strong>  Source shape.</li>\n<li><strong>target_shape:</strong>  Target shape.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Whether the source shape is broadcastable to the target shape.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">target_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.crop_and_then_pad_spatial", "modulename": "composable_mapping.util", "qualname": "crop_and_then_pad_spatial", "kind": "function", "doc": "<p>Crop or pad spatial dimensions starting from the first spatial dimension.</p>\n\n<p>Applies cropping first and then padding. Negative values in pads_or_crops\nindicate cropping.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tensor:</strong>  Tensor to pad or crop.</li>\n<li><strong>pads_or_crops:</strong>  Pads or crops to apply. Each element is a tuple of\npadding or cropping for the start and end of the spatial dimension.\nNegative values indicate cropping.</li>\n<li><strong>mode:</strong>  Padding mode.</li>\n<li><strong>value:</strong>  Value to pad with.</li>\n<li><strong>n_channel_dims:</strong>  Number of channel dimensions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Padded or cropped tensor.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tensor</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>,</span><span class=\"param\">\t<span class=\"n\">pads_or_crops</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;constant&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">n_channel_dims</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.is_croppable_first", "modulename": "composable_mapping.util", "qualname": "is_croppable_first", "kind": "function", "doc": "<p>Checks whether the pads or crops can be applied by applying the cropping first.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>spatial_shape:</strong>  Shape of the spatial dimensions.</li>\n<li><strong>pads_or_crops:</strong>  Pads or crops to apply. Each element is a tuple of\npadding or cropping for the start and end of the spatial dimension.\nNegative values indicate cropping.</li>\n<li><strong>mode:</strong>  Padding mode.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Whether the pads or crops can be applied by applying the cropping first.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">spatial_shape</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">pads_or_crops</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;constant&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "composable_mapping.util.includes_padding", "modulename": "composable_mapping.util", "qualname": "includes_padding", "kind": "function", "doc": "<p>Checks if pads or crops include padding (positive values).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>pads_or_crops:</strong>  Pads or crops to apply. Each element is a tuple of\npadding or cropping for the start and end of the spatial dimension.\nNegative values indicate cropping.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Whether pads or crops include padding.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pads_or_crops</span><span class=\"p\">:</span> <span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();